<!doctype html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>QA Agent Console</title>
  <style>
    :root {
      --bg: #0b1020;
      --panel: #121a2f;
      --line: #25304d;
      --text: #e8eefc;
      --muted: #9fb0d8;
      --ok: #16a34a;
      --warn: #f59e0b;
      --fail: #ef4444;
      --brand: #4f46e5;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: Inter, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: radial-gradient(1200px 500px at 20% -10%, #1b2850 0%, var(--bg) 45%);
      color: var(--text);
    }
    .wrap { max-width: 1280px; margin: 24px auto; padding: 0 16px; }
    .topbar {
      display: grid; grid-template-columns: 1fr auto auto auto; gap: 10px;
      background: rgba(18,26,47,.9); border: 1px solid var(--line); border-radius: 14px; padding: 12px;
      position: sticky; top: 10px; backdrop-filter: blur(10px); z-index: 2;
    }
    input, select, textarea, button {
      background: #0f162c; color: var(--text); border: 1px solid var(--line);
      border-radius: 10px; padding: 10px; font-size: 14px;
    }
    button { cursor: pointer; }
    .btn { background: var(--brand); border-color: #6158ff; }
    .btn.secondary { background: #1d2848; }
    .grid { display: grid; grid-template-columns: 2fr 1fr; gap: 14px; margin-top: 14px; }
    .card {
      background: rgba(18,26,47,.9); border: 1px solid var(--line); border-radius: 14px; padding: 14px;
    }
    .row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    .kpis { display: grid; grid-template-columns: repeat(5, minmax(0,1fr)); gap: 10px; }
    .kpi { background: #0f162c; border: 1px solid var(--line); border-radius: 12px; padding: 10px; }
    .kpi .v { font-size: 20px; font-weight: 700; }
    .kpi .k { color: var(--muted); font-size: 12px; margin-top: 4px; }
    .badge { padding: 4px 8px; border-radius: 999px; font-weight: 600; font-size: 12px; }
    .PASS { background: rgba(22,163,74,.15); color: #86efac; }
    .PASS_WITH_WARNINGS { background: rgba(245,158,11,.15); color: #fcd34d; }
    .FAIL { background: rgba(239,68,68,.15); color: #fca5a5; }
    table { width: 100%; border-collapse: collapse; margin-top: 8px; }
    th, td { border-bottom: 1px solid #233053; padding: 8px; text-align: left; font-size: 13px; }
    th { color: var(--muted); font-weight: 600; }
    .table-wrap { overflow:auto; border:1px solid var(--line); border-radius:10px; margin-top:8px; }
    .mini { font-size: 12px; color: var(--muted); }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }
    .code-chip { display:inline-block; padding:2px 6px; border-radius:999px; background:#1d2848; border:1px solid #2e3f68; font-size:11px; }
    .tabs { display: flex; gap: 8px; margin-bottom: 10px; }
    .tab { padding: 8px 10px; border: 1px solid var(--line); border-radius: 9px; cursor: pointer; color: var(--muted); }
    .tab.active { color: var(--text); background: #182447; }
    .panel { display: none; }
    .panel.active { display: block; }
    pre { margin: 0; background: #0f162c; border: 1px solid var(--line); border-radius: 10px; padding: 10px; overflow: auto; }
    .muted { color: var(--muted); font-size: 12px; }
    .advisory-box { margin-top: 10px; border: 1px solid var(--line); border-radius: 10px; padding: 10px; background: #0f162c; }
    .advisory-item { padding: 8px; border-radius: 8px; margin-bottom: 8px; }
    .advisory-item.warn { background: rgba(245,158,11,.12); border: 1px solid rgba(245,158,11,.35); }
    .advisory-item.info { background: rgba(79,70,229,.12); border: 1px solid rgba(79,70,229,.35); }
    .autopilot-list { margin: 8px 0 0 0; padding-left: 18px; }
    .autopilot-list li { margin: 4px 0; color: var(--muted); font-size: 13px; }
    .artifact-links { display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; }
    .artifact-link { font-size:12px; padding:4px 8px; border-radius:999px; border:1px solid #2e3f68; color:#c6d5fb; text-decoration:none; }
    .artifact-link.disabled { opacity:.5; pointer-events:none; }
    .remediation-box { margin-top:8px; border:1px solid var(--line); border-radius:10px; background:#0f162c; padding:10px; }
    .remediation-item { border:1px solid #2e3f68; border-radius:8px; padding:8px; margin-top:8px; }
    .remediation-item:first-child { margin-top:0; }
    .remediation-summary { display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; }
    .summary-chip { font-size:12px; padding:4px 8px; border:1px solid #2e3f68; border-radius:999px; background:#121c3a; color:#c6d5fb; }
    .checklist-box { margin-top:10px; border:1px dashed #2e3f68; border-radius:8px; padding:8px; background:#0b1329; }
    .checklist-copy { margin-left:auto; }
    .fine-checklist-box { margin-top:10px; border:1px solid #2e3f68; border-radius:10px; background:#0f162c; padding:10px; }
    .fine-bucket-grid { display:grid; grid-template-columns:repeat(3,minmax(0,1fr)); gap:10px; margin-top:8px; }
    .fine-bucket { border:1px solid #2e3f68; border-radius:8px; padding:8px; background:#101a36; }
    .fine-bucket ul { margin:6px 0 0 0; padding-left:18px; }
    .fine-bucket li { margin:4px 0; font-size:12px; color:var(--muted); }
    .retry-panel { margin-top:8px; border:1px solid var(--line); border-radius:10px; background:#0f162c; padding:10px; }
    .retry-grid { display:grid; grid-template-columns:repeat(2,minmax(0,1fr)); gap:10px; }
    .retry-list { margin:6px 0 0 0; padding-left:18px; }
    .retry-list li { margin:4px 0; font-size:13px; color:var(--muted); }
    .parity-drift-panel { margin-top:8px; border:1px solid rgba(245,158,11,.45); border-radius:10px; background:rgba(245,158,11,.10); padding:10px; }
    .parity-drift-list { margin:6px 0 0 0; padding-left:18px; }
    .parity-drift-list li { margin:4px 0; font-size:13px; color:#fde68a; }
    .ops-guard { margin-top:8px; border:1px solid rgba(245,158,11,.45); border-radius:10px; background:rgba(245,158,11,.10); padding:10px; color:#fde68a; }
    .validation-delta-panel { margin-top:8px; border:1px solid #2e3f68; border-radius:10px; background:#0f162c; padding:10px; }
    .gate-pill { display:inline-flex; align-items:center; gap:6px; padding:4px 10px; border-radius:999px; border:1px solid #2e3f68; background:#121c3a; font-size:12px; color:#c6d5fb; }
    .delta-badge-row { display:flex; gap:8px; flex-wrap:wrap; margin-top:6px; }
    .delta-list { margin:6px 0 0 0; padding-left:18px; }
    .delta-list li { margin:4px 0; font-size:13px; color:var(--muted); }
    .decomp-panel { margin-top:8px; border:1px solid #2e3f68; border-radius:10px; background:#0f162c; padding:10px; }
    .decomp-grid { display:grid; grid-template-columns:repeat(2,minmax(0,1fr)); gap:10px; margin-top:8px; }
    .decomp-card { border:1px solid #2e3f68; border-radius:8px; padding:8px; background:#101a36; }
    .decomp-warning { border-color: rgba(245,158,11,.5); background: rgba(245,158,11,.12); }
    .decomp-card ul { margin:6px 0 0 0; padding-left:18px; }
    .decomp-card li { margin:4px 0; font-size:12px; color:var(--muted); }
    .decomp-evidence-list { margin:6px 0 0 0; padding-left:18px; }
    .decomp-evidence-list li { margin:4px 0; font-size:12px; color:var(--muted); }
    .decomp-row-wrap { margin-top:10px; border:1px solid #2e3f68; border-radius:8px; overflow:auto; }
    .decomp-row-table { width:100%; border-collapse:collapse; min-width:720px; }
    .decomp-row-table th, .decomp-row-table td { border-bottom:1px solid #233053; padding:6px; text-align:left; font-size:12px; vertical-align:top; }
    .decomp-row-table th { color:var(--muted); font-weight:600; }
    .decomp-summary-grid { display:grid; grid-template-columns:repeat(2,minmax(0,1fr)); gap:10px; margin-top:8px; }
    .decomp-top-list { margin:6px 0 0 0; padding-left:0; list-style:none; }
    .decomp-top-list li { margin:6px 0; font-size:12px; color:var(--muted); }
    .decomp-top-row { display:flex; justify-content:space-between; gap:8px; margin-bottom:4px; }
    .decomp-meter { height:6px; border-radius:999px; background:#0a1226; border:1px solid #26345c; overflow:hidden; }
    .decomp-meter-fill { display:block; height:100%; background:linear-gradient(90deg,#4f46e5,#22d3ee); }
    .decomp-toolbar { display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; align-items:center; }
    .decomp-toolbar input, .decomp-toolbar select { padding:6px 8px; font-size:12px; border-radius:8px; }
    .decomp-muted-chip { font-size:11px; color:var(--muted); }
    .decomp-evidence-missing { color:#fcd34d; background:rgba(245,158,11,.10); }
    .drift-badge { display:inline-flex; align-items:center; gap:6px; padding:3px 8px; border-radius:999px; border:1px solid #2e3f68; background:#121c3a; font-size:12px; color:#c6d5fb; margin:4px 6px 0 0; }
    .sheet-panel { margin-top:10px; border:1px solid #2e3f68; border-radius:10px; background:#0f162c; padding:10px; }
    .sheet-grid { display:grid; grid-template-columns:repeat(2,minmax(0,1fr)); gap:8px; margin-top:8px; }
    .sheet-status-box, .sheet-schema-box { margin-top:8px; border:1px solid #2e3f68; border-radius:8px; padding:8px; background:#101a36; }
    .sheet-schema-list { margin:6px 0 0 18px; }
    .sheet-schema-list li { margin:4px 0; font-size:12px; color:var(--muted); }
    .run-progress-card { margin-top:8px; border:1px solid #2e3f68; border-radius:10px; background:#0f162c; padding:10px; }
    .run-progress-main { font-size:28px; font-weight:800; line-height:1.1; letter-spacing:.2px; }
    .run-progress-main .slash { color: var(--muted); margin:0 4px; font-weight:600; }
    .run-progress-meta { margin-top:6px; font-size:12px; color:var(--muted); }
    @media (max-width: 980px) {
      .grid { grid-template-columns: 1fr; }
      .topbar { grid-template-columns: 1fr; }
      .kpis { grid-template-columns: repeat(2, minmax(0,1fr)); }
      .decomp-grid, .decomp-summary-grid, .fine-bucket-grid, .retry-grid { grid-template-columns:1fr; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h2 style="margin:0 0 6px 0">QA Agent Console</h2>
    <div class="row" style="margin-bottom:8px;gap:8px">
      <button id="modeSimpleBtn" class="btn secondary">초보자 모드</button>
      <button id="modeAdvancedBtn" class="btn secondary">고급 모드</button>
    </div>
    <div class="muted" style="margin-bottom:10px">빠른 사용 순서: ① URL 입력 → ② 분석 또는 자동생성 클릭 → ③ 결과 TSV 복사/리포트 확인</div>

    <div class="topbar">
      <input id="baseUrlInput" type="text" placeholder="사용자 페이지 URL (예: https://user.example.com)" />
      <input id="llmProviders" class="advanced-only" type="text" placeholder="LLM 우선순위 (예: ollama,openai)" value="ollama,openai" />
      <input id="llmModel" class="advanced-only" type="text" placeholder="모델명" value="qwen2.5:0.5b" />
      <div class="row" style="justify-content:flex-end">
        <button id="setApiBaseBtn" class="btn secondary advanced-only">API 주소</button>
        <button id="testApiBtn" class="btn secondary advanced-only">연결 테스트</button>
        <button id="analyzeBtn" class="btn secondary advanced-only">1) 사이트 분석</button>
        <button id="oneClickBtn" class="btn">원클릭 전체 QA 실행</button>
      </div>
    </div>
    <div class="muted" id="apiBaseHint" style="margin-top:8px">API: same-origin (현재 도메인)</div>
    <div class="row advanced-only" style="margin-top:8px">
      <span class="muted">OpenAI 인증</span>
      <select id="openaiAuthMode"><option value="env" selected>env 사용</option><option value="apiKey">API Key 직접입력</option><option value="oauthToken">OAuth Token 입력</option></select>
      <input id="openaiCredential" type="password" placeholder="API Key 또는 OAuth Token" style="min-width:280px" />
      <button id="oauthLoginBtn" class="btn secondary">OpenAI 로그인</button>
      <button id="oauthStatusBtn" class="btn secondary">OAuth 상태</button>
      <button id="oauthLogoutBtn" class="btn secondary">OAuth 로그아웃</button>
    </div>

    <div class="grid">
      <section class="card">
        <div class="row" style="justify-content:space-between">
          <h3 style="margin:0">PM 의사결정 카드</h3>
          <span id="finalBadge" class="badge">-</span>
        </div>
        <div class="kpis" style="margin-top:10px">
          <div class="kpi"><div id="kCoverage" class="v">-</div><div class="k">Coverage</div></div>
          <div class="kpi"><div id="kConfidence" class="v">-</div><div class="k">Confidence</div></div>
          <div class="kpi"><div id="kAuthGate" class="v">-</div><div class="k">Auth Gate Pages</div></div>
          <div class="kpi"><div id="kCritical" class="v">-</div><div class="k">Critical Pages</div></div>
          <div class="kpi"><div id="kPrecision" class="v">-</div><div class="k">Form Precision</div></div>
        </div>
        <p id="riskText" class="muted" style="margin-top:10px">리스크: -</p>
        <div id="advisoryBox" class="advisory-box" style="display:none"></div>
        <div class="row" style="margin-top:10px">
          <button id="openHtml" class="btn secondary">HTML 리포트 열기</button>
          <button id="openJson" class="btn secondary">JSON 열기</button>
          <button id="openFixCsv" class="btn secondary">Fix CSV 열기</button>
          <button id="openFixXlsx" class="btn secondary">Fix XLSX 열기</button>
          <button id="copyTsv" class="btn secondary">체크리스트 TSV 복사</button>
        </div>
      </section>

      <section class="card">
        <h3 style="margin-top:0">체크리스트 생성</h3>
        <input id="checkScreen" class="advanced-only" type="text" placeholder="화면명 또는 URL (예: 로그인 화면)" />
        <textarea id="checkContext" class="advanced-only" rows="3" placeholder="추가 컨텍스트 (선택)"></textarea>
        <details class="advanced-only" style="margin:8px 0">
          <summary style="cursor:pointer;color:#9fb0d8">고급 설정 (로그인 필요한 페이지)</summary>
          <div style="margin-top:8px">
            <input id="adminBaseUrl" type="text" placeholder="관리자 페이지 URL (예: https://admin.example.com)" />
            <input id="authLoginUrl" type="text" placeholder="관리자 로그인 URL (예: https://admin.example.com/login)" style="margin-top:8px" />
            <div class="row" style="margin-top:8px">
              <input id="authUserId" type="text" placeholder="관리자 계정 ID / 이메일" style="flex:1;min-width:180px" />
              <input id="authPassword" type="password" placeholder="관리자 계정 비밀번호" style="flex:1;min-width:180px" />
            </div>
            <label style="margin-top:8px;display:block"><input id="autoUserSignup" type="checkbox" checked /> 사용자 회원가입 자동 시도 후 사용자 시나리오 실행</label>
          </div>
        </details>
        <div class="row">
          <label class="advanced-only"><input id="checkAuth" type="checkbox" /> 비로그인 접근 제어 포함</label>
          <label class="advanced-only"><input id="autoByMenu" type="checkbox" /> 메뉴맵 기준 URL 사용</label>
          <label><input id="execExhaustive" type="checkbox" /> 전수검사(느리지만 상세)</label>
          <label class="advanced-only"><input id="allowRiskyActions" type="checkbox" /> 위험액션 허용</label>
          <button id="checkBtn" class="btn secondary advanced-only">단일 체크리스트 생성</button>
          <button id="autoCheckBtn" class="btn advanced-only">전체 자동생성(사이트맵/메뉴맵)</button>
          <button id="execBtn" class="btn secondary advanced-only">체크리스트 실행</button>
          <button id="finalizeBtn" class="btn secondary advanced-only">최종시트 생성</button>
        </div>
        <div class="row advanced-only" style="margin-top:6px">
          <input id="exhaustiveDepth" type="number" min="0" max="2" value="1" style="width:120px" placeholder="전수 깊이" />
          <input id="exhaustiveBudgetMs" type="number" min="1000" step="1000" value="20000" style="width:160px" placeholder="전수 예산(ms)" />
          <span class="muted">권장: 깊이 1, 예산 20000ms</span>
        </div>
        <div class="row advanced-only" style="margin-top:6px">
          <button id="loadTemplatesBtn" class="btn secondary">전이 템플릿 불러오기</button>
          <select id="transitionTemplate" style="min-width:240px"><option value="">템플릿 선택</option></select>
          <button id="runTransitionBtn" class="btn secondary">전이검증 실행</button>
          <button id="conditionMatrixBtn" class="btn secondary">조건매트릭스 미리보기</button>
          <button id="analysisReloadBtn" class="btn secondary">분석 재조회</button>
          <button id="flowMapBtn" class="btn secondary">Flow Map 생성</button>
          <button id="structureMapBtn" class="btn secondary">Structure Map 생성</button>
          <button id="flowsRunBtn" class="btn secondary">Flows 실행</button>
          <button id="flowsFinalizeBtn" class="btn secondary">Flows 확정</button>
        </div>
        <div class="sheet-panel advanced-only">
          <div style="font-weight:700">Google Sheets 연동 (고급)</div>
          <div class="mini" style="margin-top:4px">pull-only 동기화 상태 확인/실행 및 시트 스키마 검증 결과를 조회합니다.</div>
          <div class="sheet-grid">
            <input id="sheetsIntegrationId" type="text" placeholder="integrationId (선택)" />
            <input id="sheetsSyncJobId" type="text" placeholder="syncJobId (상태 조회용, 선택)" />
            <input id="sheetsSpreadsheetId" type="text" placeholder="spreadsheetId (선택)" />
            <input id="sheetsWorksheet" type="text" placeholder="worksheet/title (선택)" />
          </div>
          <div class="row" style="margin-top:8px">
            <button id="sheetsPullBtn" class="btn secondary">Pull 동기화 실행</button>
            <button id="sheetsStatusBtn" class="btn secondary">동기화 상태 조회</button>
            <button id="sheetsSchemaBtn" class="btn secondary">스키마 검증</button>
          </div>
          <div id="sheetsSyncSummary" class="muted" style="margin-top:6px">Sheets sync: 대기</div>
          <div id="sheetsSyncStatusBox" class="sheet-status-box mini" style="display:none"></div>
          <div id="sheetsSchemaBox" class="sheet-schema-box mini" style="display:none"></div>
        </div>
        <div id="autoProgress" class="muted" style="margin-top:8px">자동생성 상태: 대기</div>
        <div id="advancedRunProgress" class="run-progress-card advanced-only" style="display:none">
          <div style="font-weight:700">실행 진행률</div>
          <div id="advancedRunProgressMain" class="run-progress-main"><span id="advancedCompletedRows">-</span><span class="slash">/</span><span id="advancedTargetRows">-</span></div>
          <div id="advancedRunProgressMeta" class="run-progress-meta">completed_rows / target_rows</div>
        </div>
        <div id="execSummary" class="muted" style="margin-top:6px">실행 상태: 대기</div>
        <div id="opsBackendGuard" class="ops-guard advanced-only" style="display:none"></div>
        <div class="row advanced-only" style="margin-top:6px">
          <span class="muted">실패코드 필터</span>
          <select id="failCodeFilter" style="min-width:180px"><option value="ALL">ALL</option></select>
        </div>
        <div id="failCodeStats" class="muted" style="margin-top:6px">실패코드 집계: -</div>
        <div id="retryStatsPanel" class="retry-panel advanced-only" style="display:none"></div>
        <div id="parityDriftPanel" class="parity-drift-panel advanced-only" style="display:none"></div>
        <div id="antiRegressionGatePanel" class="validation-delta-panel advanced-only" style="display:none"></div>
        <div id="validationLanePanel" class="validation-delta-panel advanced-only" style="display:none"></div>
        <div id="validationDeltaPanel" class="validation-delta-panel advanced-only" style="display:none"></div>
        <div id="remediationHints" class="remediation-box advanced-only" style="display:none"></div>
        <div id="execEvidenceHint" class="mini" style="margin-top:6px">실행 증거 상세: 대기</div>
        <div class="table-wrap" id="execRowsWrap" style="display:none; max-height:280px;">
          <table>
            <thead>
              <tr>
                <th>#</th><th>결과</th><th>화면/구분</th><th>테스트시나리오</th><th>실패코드</th><th>실패사유</th><th>증거</th><th>실행메타</th>
              </tr>
            </thead>
            <tbody id="execRowsBody"></tbody>
          </table>
        </div>
        <div id="fineErrorDecompPanel" class="decomp-panel advanced-only" style="display:none"></div>
        <div id="transitionSummary" class="muted" style="margin-top:6px">전이검증 상태: 대기</div>
        <div id="oneClickProgress" class="advisory-box" style="margin-top:8px; display:none"></div>
        <pre id="checkOut" style="margin-top:8px; max-height:210px">(생성 후 TSV 복사)</pre>
        <div id="fineChecklistBox" class="fine-checklist-box advanced-only" style="display:none"></div>
      </section>
    </div>

    <section class="card" style="margin-top:14px">
      <h3 style="margin:0">Autopilot 진행 카드</h3>
      <div class="muted" style="margin-top:4px">원클릭 UX는 그대로 유지하면서 현재 자동화 진행만 보여줍니다.</div>
      <div class="row" style="margin-top:10px; align-items:flex-start">
        <div style="flex:1; min-width:220px">
          <div style="font-weight:600">최근 완료</div>
          <ul id="autopilotDoneList" class="autopilot-list">
            <li>대기 중</li>
          </ul>
        </div>
        <div style="flex:1; min-width:220px">
          <div style="font-weight:600">진행 중 워크스트림</div>
          <ul id="autopilotActiveList" class="autopilot-list">
            <li>요청 대기</li>
          </ul>
        </div>
      </div>
      <div style="margin-top:10px; font-weight:600">아티팩트 링크</div>
      <div class="artifact-links">
        <a id="autopilotHtmlLink" class="artifact-link disabled" href="#" target="_blank">HTML 리포트 (대기)</a>
        <a id="autopilotJsonLink" class="artifact-link disabled" href="#" target="_blank">JSON 리포트 (대기)</a>
        <a id="autopilotFixLink" class="artifact-link disabled" href="#" target="_blank">Fix 시트 (대기)</a>
      </div>
    </section>

    <section class="card" style="margin-top:14px">
      <div class="tabs">
        <div class="tab active" data-tab="sitemap">Site Map</div>
        <div class="tab" data-tab="menu">Menu Map</div>
        <div class="tab" data-tab="logs">Logs/Raw</div>
      </div>

      <div id="panel-sitemap" class="panel active">
        <table>
          <thead><tr><th>Depth</th><th>Role</th><th>Path</th><th>Priority</th><th>Status</th></tr></thead>
          <tbody id="sitemapRows"></tbody>
        </table>
      </div>

      <div id="panel-menu" class="panel">
        <table>
          <thead><tr><th>Scope</th><th>Zone</th><th>Name</th><th>Href</th><th>Count</th></tr></thead>
          <tbody id="menuRows"></tbody>
        </table>
      </div>

      <div id="panel-logs" class="panel">
        <pre id="rawOut">(대기 중)</pre>
      </div>
    </section>
  </div>

<script>
  let lastReportPath = '';
  let lastReportJson = '';
  let lastFixCsv = '';
  let lastFixXlsx = '';
  let lastChecklistTSV = '';
  let lastExecutedRows = [];
  let lastTemplates = [];
  let lastAnalysisId = '';
  let lastFlows = [];
  let lastValidationDelta = null;
  let lastValidationLaneStatus = null;
  let lastAntiRegressionGate = null;
  let lastFineErrorDecomp = null;
  let autopilotDone = ['대기 중'];
  let autopilotActive = ['요청 대기'];
  let lastSheetsSyncStatus = null;
  let lastSheetsSchemaValidation = null;
  let lastRunProgress = { completed: null, target: null };

  function pickFirstNumber(...vals) {
    for (const v of vals) {
      if (v == null || v === '') continue;
      const n = Number(v);
      if (Number.isFinite(n)) return n;
    }
    return null;
  }

  function updateAdvancedRunProgress(payload = null, fallback = null) {
    const card = document.getElementById('advancedRunProgress');
    const completedEl = document.getElementById('advancedCompletedRows');
    const targetEl = document.getElementById('advancedTargetRows');
    const metaEl = document.getElementById('advancedRunProgressMeta');
    if (!card || !completedEl || !targetEl || !metaEl) return;

    const root = (payload && typeof payload === 'object') ? payload : {};
    const progress = (root.progress && typeof root.progress === 'object') ? root.progress : {};
    const summary = (root.summary && typeof root.summary === 'object') ? root.summary : {};

    const completed = pickFirstNumber(
      root.completed_rows, root.completedRows, progress.completed_rows, progress.completedRows,
      progress.done_rows, progress.doneRows, summary.completed_rows, summary.completedRows,
      fallback?.completed, lastRunProgress.completed
    );
    const target = pickFirstNumber(
      root.target_rows, root.targetRows, progress.target_rows, progress.targetRows,
      progress.total_rows, progress.totalRows, summary.target_rows, summary.targetRows,
      fallback?.target, lastRunProgress.target
    );

    lastRunProgress = { completed, target };
    card.style.display = '';
    completedEl.textContent = completed != null ? String(completed) : '-';
    targetEl.textContent = target != null ? String(target) : '-';

    const pct = (completed != null && target != null && target > 0) ? ` (${Math.round((completed/target)*100)}%)` : '';
    metaEl.textContent = `completed_rows / target_rows${pct}`;
  }

  function resetAdvancedRunProgress() {
    lastRunProgress = { completed: null, target: null };
    updateAdvancedRunProgress({});
  }

  function setUIMode(mode) {
    const m = mode === 'advanced' ? 'advanced' : 'simple';
    localStorage.setItem('QA_UI_MODE', m);
    document.querySelectorAll('.advanced-only').forEach(el => {
      el.style.display = (m === 'advanced') ? '' : 'none';
    });
    const s = document.getElementById('modeSimpleBtn');
    const a = document.getElementById('modeAdvancedBtn');
    if (s && a) {
      s.style.opacity = (m === 'simple') ? '1' : '0.7';
      a.style.opacity = (m === 'advanced') ? '1' : '0.7';
    }
    renderValidationLanePanel(lastValidationLaneStatus);
    renderValidationDeltaPanel(lastValidationDelta);
    renderAntiRegressionGatePanel(lastAntiRegressionGate);
    renderFineErrorDecompPanel(lastFineErrorDecomp);
  }

  function getApiBase() {
    const fromGlobal = (window.QA_API_BASE || '').trim();
    const fromStorage = (localStorage.getItem('QA_API_BASE') || '').trim();
    const fromQuery = (new URLSearchParams(location.search).get('apiBase') || '').trim();
    const base = fromQuery || fromGlobal || fromStorage || '';
    return base.replace(/\/$/, '');
  }

  function apiUrl(path) {
    const base = getApiBase();
    return base ? `${base}${path}` : path;
  }

  function refreshApiHint(statusText = '') {
    const base = getApiBase();
    const originText = base ? `API: ${base}` : 'API: same-origin (현재 도메인)';
    document.getElementById('apiBaseHint').textContent = statusText ? `${originText} | ${statusText}` : originText;
  }

  async function testApiConnection(silent = false) {
    if (!silent) setButtonBusy('testApiBtn', true, '테스트중...');
    try {
      let ok = false;
      let detail = '';

      // fastapi health
      try {
        const rh = await fetch(apiUrl('/health'));
        const jh = await rh.json();
        if (rh.ok && (jh.ok === true || jh.service)) {
          ok = true;
          detail = 'health ok';
        }
      } catch (_) {}

      // fallback: node root/html check
      if (!ok) {
        try {
          const rr = await fetch(apiUrl('/'));
          if (rr.ok) {
            ok = true;
            detail = 'root ok';
          }
        } catch (_) {}
      }

      if (ok) {
        refreshApiHint('연결됨 ✅');
        if (!silent) alert('API 연결 성공 (' + detail + ')');
      } else {
        refreshApiHint('연결 실패 ❌');
        if (!silent) alert('API 연결 실패: 주소 또는 CORS 설정 확인 필요');
      }
    } catch (e) {
      refreshApiHint('연결 실패 ❌');
      if (!silent) alert('API 연결 실패: ' + (e?.message || e));
    } finally {
      if (!silent) setButtonBusy('testApiBtn', false);
    }
  }

  const DEFAULT_MODEL = {
    ollama: 'qwen2.5:0.5b',
    openai: 'gpt-4o-mini',
  };

  function getLLMOptions() {
    const providersRaw = (document.getElementById('llmProviders')?.value || 'ollama').trim();
    const providers = providersRaw.split(',').map(s => s.trim()).filter(Boolean);
    const llmProvider = providers.length ? providers.join(',') : 'ollama';
    const mode = (document.getElementById('openaiAuthMode')?.value || 'env').trim();
    const cred = (document.getElementById('openaiCredential')?.value || '').trim();
    const openaiAuth = (mode === 'apiKey') ? { apiKey: cred } : (mode === 'oauthToken' ? { oauthToken: cred } : {});
    return {
      llmProvider,
      llmProviders: providers,
      llmModel: (document.getElementById('llmModel').value || '').trim(),
      llmRouting: { providers, auth: { openai: { mode, ...openaiAuth } } },
      llmAuth: { openai: { mode, ...openaiAuth } },
    };
  }

  function getAuthOptions() {
    const loginUrl = (document.getElementById('authLoginUrl')?.value || '').trim();
    const userId = (document.getElementById('authUserId')?.value || '').trim();
    const password = (document.getElementById('authPassword')?.value || '').trim();
    return { auth: { loginUrl, userId, password } };
  }

  function getDualContext() {
    const userBaseUrl = (document.getElementById('baseUrlInput')?.value || '').trim();
    const adminBaseUrl = (document.getElementById('adminBaseUrl')?.value || '').trim() || userBaseUrl;
    const autoUserSignup = !!document.getElementById('autoUserSignup')?.checked;
    return { userBaseUrl, adminBaseUrl, autoUserSignup };
  }

  function setBadge(status) {
    const b = document.getElementById('finalBadge');
    b.className = 'badge ' + (status || '');
    b.textContent = status || '-';
  }

  function setButtonBusy(id, busy, busyText = '처리중...') {
    const btn = document.getElementById(id);
    if (!btn) return;
    if (busy) {
      if (!btn.dataset.originalText) btn.dataset.originalText = btn.textContent;
      btn.disabled = true;
      btn.textContent = busyText;
    } else {
      btn.disabled = false;
      if (btn.dataset.originalText) btn.textContent = btn.dataset.originalText;
    }
  }

  function renderAutopilotCard() {
    const doneEl = document.getElementById('autopilotDoneList');
    const activeEl = document.getElementById('autopilotActiveList');
    doneEl.innerHTML = autopilotDone.slice(-5).map(x => `<li>${x}</li>`).join('');
    activeEl.innerHTML = (autopilotActive.length ? autopilotActive : ['없음']).map(x => `<li>${x}</li>`).join('');
  }

  function setArtifactLink(id, path, readyText, waitText) {
    const el = document.getElementById(id);
    if (!el) return;
    if (path) {
      el.classList.remove('disabled');
      el.href = fileUrl(path);
      el.textContent = readyText;
    } else {
      el.classList.add('disabled');
      el.href = '#';
      el.textContent = waitText;
    }
  }

  function refreshAutopilotArtifacts() {
    setArtifactLink('autopilotHtmlLink', lastReportPath, 'HTML 리포트 열기', 'HTML 리포트 (대기)');
    setArtifactLink('autopilotJsonLink', lastReportJson, 'JSON 리포트 열기', 'JSON 리포트 (대기)');
    setArtifactLink('autopilotFixLink', lastFixXlsx || lastFixCsv, 'Fix 시트 열기', 'Fix 시트 (대기)');
  }

  function autopilotStart() {
    autopilotDone = ['요청 접수'];
    autopilotActive = ['분석 준비', '플로우 생성 대기'];
    renderAutopilotCard();
    refreshAutopilotArtifacts();
  }

  function autopilotStepDone(text, nextActive = []) {
    autopilotDone.push(text);
    autopilotActive = nextActive;
    renderAutopilotCard();
  }

  function updateKPIs(quality, finalStatus) {
    document.getElementById('kCoverage').textContent = quality?.metrics?.coverageScore ?? '-';
    document.getElementById('kConfidence').textContent = quality?.confidence ?? '-';
    document.getElementById('kAuthGate').textContent = quality?.metrics?.authGatePages ?? '-';
    document.getElementById('kCritical').textContent = quality?.metrics?.criticalPages ?? '-';
    document.getElementById('kPrecision').textContent = quality?.formPrecision?.precisionScore ?? '-';
    document.getElementById('riskText').textContent = '리스크: ' + ((quality?.risks || []).join(' | ') || '-');
    setBadge(finalStatus);
  }

  function renderAdvisories(advisories) {
    const box = document.getElementById('advisoryBox');
    const rows = Array.isArray(advisories) ? advisories : [];
    if (!rows.length) {
      box.style.display = 'none';
      box.innerHTML = '';
      return;
    }
    box.style.display = 'block';
    box.innerHTML = '<div style="font-weight:700; margin-bottom:8px;">접근/수집 안내</div>' + rows.map(a => {
      const level = String(a?.severity || 'INFO').toLowerCase();
      const cls = level === 'warn' ? 'warn' : 'info';
      const msg = a?.message || '';
      const action = a?.action || '';
      const need = a?.needsCredentials ? ' • 테스트 계정(ID/PW) 필요' : '';
      return `<div class="advisory-item ${cls}"><div><b>${a?.type || 'ADVISORY'}</b>${need}</div><div>${msg}</div><div class="muted" style="margin-top:4px">${action}</div></div>`;
    }).join('');
  }

  function fileUrl(path) {
    const clean = String(path || '').replace(/^\//, '');
    const base = getApiBase();
    return base ? `${base}/${clean}` : `/${clean}`;
  }

  async function loadReports(paths) {
    if (!paths?.sitemapPath || !paths?.menuPath) return null;
    const sitemap = await (await fetch(fileUrl(paths.sitemapPath))).json();
    const menu = await (await fetch(fileUrl(paths.menuPath))).json();
    const quality = paths.qualityPath ? await (await fetch(fileUrl(paths.qualityPath))).json() : null;

    const sbody = document.getElementById('sitemapRows');
    sbody.innerHTML = '';
    (sitemap.rows || []).slice(0, 40).forEach(r => {
      const tr = document.createElement('tr');
      tr.innerHTML = `<td>${r.depth}</td><td>${r.role}</td><td><code>${r.path}</code></td><td>${r.priorityTier} (${r.priorityScore})</td><td>${r.httpStatus||'-'}</td>`;
      sbody.appendChild(tr);
    });

    const mbody = document.getElementById('menuRows');
    mbody.innerHTML = '';
    (menu.rows || []).slice(0, 40).forEach(r => {
      const tr = document.createElement('tr');
      tr.innerHTML = `<td>${r.scope}</td><td>${r.zone}</td><td>${r.name}</td><td><code>${r.href}</code></td><td>${r.count}</td>`;
      mbody.appendChild(tr);
    });

    return { sitemap, menu, quality };
  }

  async function onAnalyze() {
    const baseUrl = document.getElementById('baseUrlInput').value.trim();
    if (!baseUrl) return alert('URL 입력');
    setButtonBusy('analyzeBtn', true, '분석중...');
    try {
      const body = { baseUrl, ...getLLMOptions(), ...getAuthOptions() };
      const j = await (await fetch(apiUrl('/api/analyze'), { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body) })).json();
      document.getElementById('rawOut').textContent = JSON.stringify(j, null, 2);
      if (j.ok) {
        lastAnalysisId = j.analysisId || lastAnalysisId;
        const reports = await loadReports(j.reports);
        updateKPIs(reports?.quality, '-');
        renderAdvisories(j.advisories || []);
        await refreshAntiRegressionGate(j);
        await refreshValidationDelta(j);
      }
    } finally {
      setButtonBusy('analyzeBtn', false);
    }
  }

  async function asJson(res) {
    const t = await res.text();
    try { return JSON.parse(t); }
    catch (_) {
      if ((t || '').startsWith('<!DOCTYPE') || (t || '').startsWith('<html')) {
        throw new Error('API가 JSON 대신 HTML을 반환했습니다. API 주소를 설정하세요.');
      }
      throw new Error('JSON 파싱 실패: ' + t.slice(0, 120));
    }
  }

  async function postJson(path, body, timeoutMs = 120000, retries = 2) {
    let lastErr = null;
    for (let i = 0; i <= retries; i++) {
      const ctl = new AbortController();
      const t = setTimeout(() => ctl.abort(), timeoutMs);
      try {
        const res = await fetch(apiUrl(path), {
          method:'POST',
          headers:{'Content-Type':'application/json'},
          body: JSON.stringify(body || {}),
          signal: ctl.signal,
        });
        clearTimeout(t);
        return await asJson(res);
      } catch (e) {
        clearTimeout(t);
        lastErr = e;
        if (i < retries) await new Promise(r => setTimeout(r, 1200 * (i + 1)));
      }
    }
    throw new Error('네트워크/타임아웃 오류: ' + (lastErr?.message || lastErr));
  }

  async function getJson(path, timeoutMs = 30000) {
    const ctl = new AbortController();
    const t = setTimeout(() => ctl.abort(), timeoutMs);
    try {
      const res = await fetch(apiUrl(path), { signal: ctl.signal });
      return await asJson(res);
    } finally {
      clearTimeout(t);
    }
  }

  function stageLog(msg, ok = null) {
    const box = document.getElementById('oneClickProgress');
    box.style.display = 'block';
    const color = ok === true ? '#86efac' : (ok === false ? '#fca5a5' : '#9fb0d8');
    box.innerHTML += `<div style="color:${color};margin:2px 0">• ${msg}</div>`;
  }

  async function executeChecklistBatches(allRows, opts, batchSize = 20) {
    const merged = { ok: true, rows: [], summary: { PASS:0, FAIL:0, BLOCKED:0 }, coverage: {} };
    for (let i = 0; i < allRows.length; i += batchSize) {
      const batch = allRows.slice(i, i + batchSize);
      stageLog(`3/8 실행 배치 ${Math.floor(i/batchSize)+1}/${Math.ceil(allRows.length/batchSize)} (${batch.length} rows)`);
      const j = await postJson('/api/checklist/execute', {
        projectName:'QA 실행 결과',
        rows: batch,
        maxRows: batch.length,
        ...opts,
        ...getAuthOptions()
      }, 240000, 2);
      if (!j.ok) throw new Error('checklist/execute 배치 실패');
      const s = j.summary || {};
      merged.summary.PASS += (s.PASS || 0);
      merged.summary.FAIL += (s.FAIL || 0);
      merged.summary.BLOCKED += (s.BLOCKED || 0);
      merged.rows.push(...(j.rows || []));
      merged.coverage = j.coverage || merged.coverage;
    }
    return merged;
  }

  async function onOneClick() {
    const { userBaseUrl, adminBaseUrl, autoUserSignup } = getDualContext();
    if (!userBaseUrl) return alert('사용자 페이지 URL 입력');
    setButtonBusy('oneClickBtn', true, '원클릭 실행중...');
    const raw = document.getElementById('rawOut');
    const p = document.getElementById('oneClickProgress');
    p.innerHTML = '<div style="font-weight:700;margin-bottom:6px">원클릭 진행 과정 (사용자/관리자 분리)</div>';
    p.style.display = 'block';

    try {
      autopilotStart();
      stageLog('1/3 통합 oneclick(dual) 요청 시작');
      autopilotStepDone('원클릭 요청 전송', ['사용자 분석 진행 중', '관리자 분석 대기']);
      const j = await postJson('/api/oneclick', {
        dualContext: {
          userBaseUrl,
          adminBaseUrl,
          autoUserSignup,
          adminAuth: getAuthOptions().auth,
        },
        ...getLLMOptions(),
      }, 300000, 1);
      raw.textContent = JSON.stringify(j, null, 2);
      if (!j.ok) throw new Error('oneclick dual 실패');

      stageLog('2/3 사용자/관리자 파이프라인 완료', true);
      autopilotStepDone('사용자/관리자 파이프라인 완료', ['리포트 정리 중', '아티팩트 링크 갱신 중']);
      const user = j.user || {};
      const admin = j.admin || {};
      (j.userPhase || []).forEach(p => stageLog(`userPhase ${p.name}: ${p.status}`));
      (j.adminPhase || []).forEach(p => stageLog(`adminPhase ${p.name}: ${p.status}`));
      (j.bridgePhase || []).forEach(p => stageLog(`bridgePhase ${p.name}: ${p.status}`));
      lastAnalysisId = user.analysisId || lastAnalysisId;
      lastReportPath = user.reportPath || lastReportPath;
      lastReportJson = user.reportJson || lastReportJson;
      lastFixCsv = user.fixSheet?.csv || lastFixCsv;
      lastFixXlsx = user.fixSheet?.xlsx || lastFixXlsx;
      document.getElementById('execSummary').textContent = `실행 상태(사용자): ${JSON.stringify(user.summary || {})} | (관리자): ${JSON.stringify(admin.summary || {})}`;
      refreshAutopilotArtifacts();

      const reports = user.analysisReports || {};
      if (reports.sitemapPath && reports.menuPath) {
        const loaded = await loadReports(reports);
        updateKPIs(loaded?.quality, j.finalStatus || user.finalStatus);
      } else {
        setBadge(j.finalStatus || user.finalStatus || '-');
      }

      stageLog('3/3 완료', true);
      autopilotStepDone('리포트/아티팩트 갱신 완료', []);
      await refreshAntiRegressionGate(j);
      await refreshValidationDelta(j);
      alert('원클릭 전체 QA 완료');
    } catch (e) {
      autopilotStepDone('실행 실패: ' + (e?.message || e), ['오류 확인 필요']);
      stageLog('실패: ' + (e?.message || e), false);
      alert('원클릭 실패: ' + (e?.message || e));
    } finally {
      setButtonBusy('oneClickBtn', false);
    }
  }

  async function onAutoChecklist() {
    const baseUrl = document.getElementById('baseUrlInput').value.trim();
    if (!baseUrl) return alert('URL 입력');
    const raw = document.getElementById('rawOut');
    const progress = document.getElementById('autoProgress');

    try {
      setButtonBusy('autoCheckBtn', true, '자동생성중...');
      progress.textContent = '자동생성 상태: 1/3 사이트맵 분석 중...';
      raw.textContent = '자동 체크리스트 생성 중... (analyze → screenshot → checklist)';

      const analyzed = await (await fetch(apiUrl('/api/analyze'), {
        method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ baseUrl, ...getLLMOptions(), ...getAuthOptions() })
      })).json();
      lastAnalysisId = analyzed.analysisId || lastAnalysisId;
      if (!analyzed.ok || !analyzed.analysisId) {
        raw.textContent = JSON.stringify(analyzed, null, 2);
        progress.textContent = '자동생성 상태: 실패 (analyze)';
        return alert('analyze 실패');
      }

      const source = document.getElementById('autoByMenu').checked ? 'menu' : 'sitemap';
      progress.textContent = `자동생성 상태: 2/3 ${source==='menu'?'메뉴맵':'사이트맵'} URL별 스크린샷 + 체크리스트 생성 중...`;
      const auto = await (await fetch(apiUrl('/api/checklist/auto'), {
        method:'POST', headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ analysisId: analyzed.analysisId, includeAuth: true, source, ...getLLMOptions(), ...getAuthOptions() })
      })).json();

      raw.textContent = JSON.stringify(auto, null, 2);
      renderFineChecklistBuckets(auto);
      if (auto.ok) {
        document.getElementById('checkOut').textContent = auto.tsv || '';
        lastChecklistTSV = auto.tsv || '';
        const shots = (auto.pageResults || []).map(x => x?.screenshot?.screenshotPath).filter(Boolean);
        progress.textContent = `자동생성 상태: 3/3 완료 (페이지 ${auto.pagesAudited}, 스크린샷 성공 ${auto.screenshotOk ?? shots.length})`;
        alert(`자동 생성 완료: ${auto.pagesAudited}개 페이지\n스크린샷 성공 ${auto.screenshotOk ?? shots.length} / 실패 ${auto.screenshotFailed ?? Math.max(0, (auto.pagesAudited||0)-shots.length)}`);
      } else {
        progress.textContent = '자동생성 상태: 실패 (auto checklist)';
      }
    } catch (e) {
      progress.textContent = '자동생성 상태: 실패 (예외 발생)';
      raw.textContent = String(e?.message || e);
    } finally {
      setButtonBusy('autoCheckBtn', false);
    }
  }

  function parseTSV(tsv) {
    const text = String(tsv || '').trim();
    if (!text) return [];
    const lines = text.split(/\r?\n/).filter(Boolean);
    if (lines.length < 2) return [];
    const cols = lines[0].split('\t');
    return lines.slice(1).map(line => {
      const vals = line.split('\t');
      const row = {};
      cols.forEach((c, i) => row[c] = vals[i] || '');
      return row;
    });
  }

  function normalizeBucketItems(raw) {
    if (!Array.isArray(raw)) return [];
    return raw.map((item) => {
      if (typeof item === 'string') return item.trim();
      if (item && typeof item === 'object') {
        const text = item.label || item.name || item.scenario || item.test || item.value || item.desc || item.description || item.message;
        return String(text || '').trim();
      }
      return String(item || '').trim();
    }).filter(Boolean);
  }

  function extractFineChecklistBuckets(payload) {
    const root = (payload && typeof payload === 'object') ? payload : {};
    const source = root.fineGrainedChecklist || root.expandedChecklist || root.checklistBuckets || root.buckets || root.groupedChecklist || null;
    if (!source || typeof source !== 'object') return null;

    const field = normalizeBucketItems(source.field || source.fields || source.inputs || source.requiredFields);
    const action = normalizeBucketItems(source.action || source.actions || source.interactions || source.steps);
    const assertion = normalizeBucketItems(source.assertion || source.assertions || source.expectations || source.checks);

    if (!field.length && !action.length && !assertion.length) return null;
    return { field, action, assertion };
  }

  function renderFineChecklistBuckets(payload) {
    const box = document.getElementById('fineChecklistBox');
    if (!box) return;

    const uiMode = (localStorage.getItem('QA_UI_MODE') || 'simple').trim();
    if (uiMode !== 'advanced') {
      box.style.display = 'none';
      box.innerHTML = '';
      return;
    }

    const buckets = extractFineChecklistBuckets(payload);
    if (!buckets) {
      box.style.display = 'none';
      box.innerHTML = '';
      return;
    }

    const bucketCard = (title, list) => `
      <div class="fine-bucket">
        <div style="font-weight:600">${title} <span class="mini">(${list.length})</span></div>
        <ul>${(list.length ? list : ['(없음)']).map((x) => `<li>${safeText(x)}</li>`).join('')}</ul>
      </div>
    `;

    box.style.display = 'block';
    box.innerHTML = `
      <div style="font-weight:700">고급 체크리스트 그룹</div>
      <div class="mini" style="margin-top:4px">fine-grained bucket 데이터가 있을 때만 표시됩니다.</div>
      <div class="fine-bucket-grid">
        ${bucketCard('Field', buckets.field)}
        ${bucketCard('Action', buckets.action)}
        ${bucketCard('Assertion', buckets.assertion)}
      </div>
    `;
  }

  function normalizeFailCode(raw) {
    const code = String(raw || '').trim();
    return code && code !== 'OK' ? code : 'UNKNOWN';
  }

  function normalizeDecompName(raw, fallback = '-') {
    const text = String(raw || '').trim();
    return text || fallback;
  }

  function normalizeGroupLabel(raw, fallback = '미분류') {
    const text = String(raw || '').trim();
    return text || fallback;
  }

  function normalizeDecompRows(payload) {
    const root = (payload && typeof payload === 'object') ? payload : {};
    const buckets = [
      root.executedDecompositionRows,
      root.executedDecomposition?.rows,
      root.fineErrorDecompositionRows,
      root.fineErrorDecomposition?.rows,
      root.errorDecompositionRows,
      root.errorDecomposition?.rows,
      root.decompositionRows,
      root.decomposition?.rows,
      root.summary?.executedDecompositionRows,
      root.summary?.decompositionRows,
      root.meta?.executedDecompositionRows,
      root.meta?.decompositionRows,
    ];
    const source = buckets.find((x) => Array.isArray(x));
    if (!Array.isArray(source) || !source.length) return [];

    return source.map((row) => {
      const r = (row && typeof row === 'object') ? row : {};
      const screen = normalizeGroupLabel(r.screen || r['화면'] || r.page || r.pageName || r.route || r.urlHost || r.path);
      const section = normalizeGroupLabel(r.section || r['섹션'] || r.group || r.module || r.component || r.zone || r.block);
      const field = normalizeDecompName(r.field || r['필드'] || r.fieldName || r.targetField);
      const action = normalizeDecompName(r.action || r['액션'] || r.stepAction || r.interaction);
      const assertion = normalizeDecompName(r.assertion || r['검증'] || r.expectation || r.assert);
      const error = normalizeFailCode(r.errorCode || r.code || r.error || r['실패코드']);
      const evidenceRaw = String(r.evidence || r.message || r.reason || r['증거'] || '').trim();
      const hasEvidence = Boolean(evidenceRaw);
      const evidence = hasEvidence ? evidenceRaw : '(증거 없음)';
      return { screen, section, field, action, assertion, error, evidence, hasEvidence };
    }).filter((x) => x.field !== '-' || x.action !== '-' || x.assertion !== '-' || x.error !== 'UNKNOWN' || x.evidence !== '(증거 없음)');
  }

  function normalizeDensityMetrics(payload, rows = []) {
    const root = (payload && typeof payload === 'object') ? payload : {};
    const candidates = [
      root.decompositionDensity,
      root.decompositionDensityMetrics,
      root.fineErrorDecomposition?.density,
      root.fineErrorDecomposition?.metrics,
      root.executedDecomposition?.density,
      root.executedDecomposition?.metrics,
      root.decomposition?.density,
      root.decomposition?.metrics,
      root.summary?.decompositionDensity,
      root.summary?.decompositionDensityMetrics,
      root.summary?.density,
      root.meta?.decompositionDensity,
      root.meta?.decompositionDensityMetrics,
      root.finalize?.decompositionDensity,
      root.finalize?.decompositionDensityMetrics,
      root.report?.decompositionDensity,
      root.report?.decompositionDensityMetrics,
      root.finalSheet?.decompositionDensity,
      root.finalSheet?.decompositionDensityMetrics,
    ].filter((x) => x && typeof x === 'object');

    const pickNum = (obj, keys) => {
      if (!obj || typeof obj !== 'object') return null;
      for (const key of keys) {
        const v = toNum(obj[key]);
        if (v != null) return v;
      }
      return null;
    };

    let rowSplitRatio = null;
    let evidenceLinkageRate = null;
    let source = null;

    for (const obj of candidates) {
      rowSplitRatio = pickNum(obj, ['rowSplitRatio', 'row_split_ratio', 'splitRatio', 'rowSplitRate']);
      evidenceLinkageRate = pickNum(obj, ['evidenceLinkageRate', 'evidence_linkage_rate', 'linkageRate', 'evidenceRate']);
      if (rowSplitRatio != null || evidenceLinkageRate != null) {
        source = 'payload';
        break;
      }
    }

    if (rowSplitRatio == null && evidenceLinkageRate == null && Array.isArray(rows) && rows.length) {
      const rowCount = rows.length;
      const splitRows = rows.filter((row) => {
        const token = `${safeText(row.field)} ${safeText(row.action)} ${safeText(row.assertion)}`;
        return token.includes('/') || token.includes('>') || token.includes(',');
      }).length;
      const linkedRows = rows.filter((row) => {
        const evidence = String(row.evidence || '').trim();
        return evidence && evidence !== '(증거 없음)';
      }).length;
      rowSplitRatio = rowCount ? splitRows / rowCount : null;
      evidenceLinkageRate = rowCount ? linkedRows / rowCount : null;
      source = 'derived';
    }

    if (rowSplitRatio == null && evidenceLinkageRate == null) return null;
    return { rowSplitRatio, evidenceLinkageRate, source };
  }

  function collectErrorDecomposition(rows, payload = null) {
    const backendRows = normalizeDecompRows(payload);
    const list = Array.isArray(rows) ? rows : [];
    const fieldCounts = {};
    const actionCounts = {};
    const assertionCounts = {};
    const codeCounts = {};
    const screenCounts = {};
    const sectionCounts = {};
    const evidenceRows = [];
    const decompRows = [];

    const pushStats = (row) => {
      fieldCounts[row.field] = (fieldCounts[row.field] || 0) + 1;
      actionCounts[row.action] = (actionCounts[row.action] || 0) + 1;
      assertionCounts[row.assertion] = (assertionCounts[row.assertion] || 0) + 1;
      codeCounts[row.error] = (codeCounts[row.error] || 0) + 1;
      screenCounts[row.screen] = (screenCounts[row.screen] || 0) + 1;
      sectionCounts[row.section] = (sectionCounts[row.section] || 0) + 1;
      decompRows.push(row);
    };

    if (backendRows.length) {
      backendRows.forEach((row) => {
        pushStats(row);
      });
      backendRows.slice(0, 16).forEach((row) => evidenceRows.push({ scenario: `${row.screen} > ${row.section} > ${row.field} / ${row.action}`, code: row.error, evidence: row.evidence }));
    } else {
      list.forEach((r) => {
        if (String(r['실행결과'] || '').toUpperCase() === 'PASS') return;
        const meta = (r['실행메타'] && typeof r['실행메타'] === 'object') ? r['실행메타'] : {};
        const scenario = String(r['테스트시나리오'] || '').trim();
        const screen = normalizeGroupLabel(r['화면'] || r['screen'] || meta.screen || meta.page || meta.route || meta.url || scenario.split('>').shift());
        const section = normalizeGroupLabel(r['구분'] || r['section'] || meta.section || meta.module || meta.component || meta.scenarioKind);
        const field = normalizeDecompName(
          r['필드'] || r['field'] || meta.field || meta.fieldName || meta.input || meta.targetField || r['화면']
        );
        const action = normalizeDecompName(
          r['액션'] || r['action'] || meta.action || meta.stepAction || meta.interaction || meta.scenarioKind
        );
        const assertion = normalizeDecompName(
          r['검증'] || r['assertion'] || meta.assertion || meta.expectation || r['실패사유']
        );
        const error = normalizeFailCode(r['실패코드'] || r['errorCode'] || meta.errorCode || meta.failCode);
        const evidenceRaw = String(r['증거'] || meta.evidence || meta.error || '').trim();
        const hasEvidence = Boolean(evidenceRaw);

        const row = { screen, section, field, action, assertion, error, evidence: evidenceRaw || '(증거 없음)', hasEvidence };
        pushStats(row);

        if (evidenceRows.length < 16 && (evidenceRaw || scenario)) {
          evidenceRows.push({ scenario: `${screen} > ${section} > ${scenario || field}`, code: error, evidence: evidenceRaw || '(증거 없음)' });
        }
      });
    }

    const byCountDesc = (obj) => Object.entries(obj).sort((a, b) => b[1] - a[1]).slice(0, 8).map(([name, count]) => ({ name, count }));
    const total = Object.values(codeCounts).reduce((acc, n) => acc + Number(n || 0), 0);
    const density = normalizeDensityMetrics(payload, decompRows);
    if (!total && !density) return null;

    const missingEvidenceRows = decompRows.filter((row) => !row.hasEvidence);
    const evidenceMissingCount = missingEvidenceRows.length;

    const nonPlaceholderRate = (key) => {
      if (!total) return 0;
      const valid = decompRows.filter((row) => String(row[key] || '').trim() && String(row[key] || '').trim() !== '-').length;
      return valid / total;
    };

    const completeness = {
      fieldCoverage: nonPlaceholderRate('field'),
      actionCoverage: nonPlaceholderRate('action'),
      assertionCoverage: nonPlaceholderRate('assertion'),
      evidenceCoverage: total ? (1 - (evidenceMissingCount / total)) : 0,
    };
    completeness.overall = (completeness.fieldCoverage + completeness.actionCoverage + completeness.assertionCoverage + completeness.evidenceCoverage) / 4;

    return {
      total,
      field: byCountDesc(fieldCounts),
      action: byCountDesc(actionCounts),
      assertion: byCountDesc(assertionCounts),
      code: byCountDesc(codeCounts),
      screen: byCountDesc(screenCounts),
      section: byCountDesc(sectionCounts),
      evidence: evidenceRows,
      evidenceMissingCount,
      evidenceMissingTop: missingEvidenceRows.slice(0, 6).map((row) => ({ screen: row.screen, section: row.section, code: row.error, scenario: `${row.field} / ${row.action}` })),
      rows: decompRows,
      density,
      completeness,
      source: backendRows.length ? 'backend' : 'derived',
    };
  }

  function renderFineErrorDecompPanel(data) {
    const box = document.getElementById('fineErrorDecompPanel');
    if (!box) return;
    const uiMode = (localStorage.getItem('QA_UI_MODE') || 'simple').trim();
    if (uiMode !== 'advanced' || !data) {
      box.style.display = 'none';
      box.innerHTML = '';
      return;
    }

    const meterList = (title, list) => {
      const arr = Array.isArray(list) ? list : [];
      const top = arr.slice(0, 6);
      const maxCount = Math.max(1, ...top.map((x) => Number(x?.count || 0)));
      return `
      <div class="decomp-card"> 
        <div style="font-weight:600">${title} <span class="mini">(${arr.length})</span></div>
        <ul class="decomp-top-list">${(top.length ? top : [{ name: '(없음)', count: 0 }]).map((x) => {
          const name = safeText(x.name || '-');
          const count = Number(x.count || 0);
          const pct = Math.round((count / maxCount) * 100);
          return `<li><div class="decomp-top-row"><span class="code-chip mono">${name}</span><span>${count}건</span></div><div class="decomp-meter"><span class="decomp-meter-fill" style="width:${pct}%"></span></div></li>`;
        }).join('')}</ul>
      </div>`;
    };

    const topActionCodes = (data.code || []).slice(0, 3);
    const actionChecklist = topActionCodes.map((row) => {
      const code = safeText(row?.name || 'UNKNOWN');
      const hint = safeText(remediationHintFor(code));
      const count = Number(row?.count || 0);
      return `<li><span class="code-chip mono">${code}</span> (${count}건) · ${hint}</li>`;
    }).join('');

    const density = (data && typeof data.density === 'object') ? data.density : null;
    const ratioLabel = (v) => (v == null ? '-' : `${(Number(v) * 100).toFixed(1)}%`);
    const densityBadges = density ? `<span class="summary-chip">Row split ratio: ${ratioLabel(density.rowSplitRatio)}</span><span class="summary-chip">Evidence linkage rate: ${ratioLabel(density.evidenceLinkageRate)}</span><span class="summary-chip">density source: ${safeText(density.source || 'payload')}</span>` : '';

    const completeness = (data && typeof data.completeness === 'object') ? data.completeness : null;
    const completenessBadges = completeness ? `
      <span class="summary-chip">완성도 ${(Number(completeness.overall || 0) * 100).toFixed(1)}%</span>
      <span class="summary-chip">Field ${(Number(completeness.fieldCoverage || 0) * 100).toFixed(0)}%</span>
      <span class="summary-chip">Action ${(Number(completeness.actionCoverage || 0) * 100).toFixed(0)}%</span>
      <span class="summary-chip">Assertion ${(Number(completeness.assertionCoverage || 0) * 100).toFixed(0)}%</span>
      <span class="summary-chip">Evidence ${(Number(completeness.evidenceCoverage || 0) * 100).toFixed(0)}%</span>` : '';

    const evidenceMissingCount = Number(data.evidenceMissingCount || 0);
    const evidenceWarning = evidenceMissingCount > 0
      ? `<div class="decomp-card decomp-warning" style="margin-top:8px"><div style="font-weight:600">⚠️ Evidence 누락 경고 (${evidenceMissingCount}건)</div><ul class="decomp-evidence-list">${(data.evidenceMissingTop || []).map((x) => `<li><span class="code-chip mono">${safeText(x.code)}</span> ${safeText(x.screen)} > ${safeText(x.section)} > ${safeText(x.scenario)}</li>`).join('') || '<li>(샘플 없음)</li>'}</ul></div>`
      : '';

    box.style.display = 'block';
    box.innerHTML = `
      <div style="font-weight:700">Fine-grained Error Decomposition</div>
      <div class="mini" style="margin-top:4px">실패/차단 행을 화면·섹션·Field·Action·Assertion·Error·Evidence로 분해합니다. (고급 모드 전용)</div>
      <div class="delta-badge-row" style="margin-top:6px"><span class="summary-chip">대상 ${safeText(data.total)}건</span><span class="summary-chip">source: ${safeText(data.source || 'unknown')}</span>${densityBadges}${completenessBadges}</div>
      ${evidenceWarning}
      ${(topActionCodes.length ? `<div class="decomp-card" style="margin-top:8px"><div style="font-weight:600">즉시 조치 우선순위 (Top error code)</div><ul class="decomp-evidence-list">${actionChecklist}</ul></div>` : '')}
      <div class="decomp-summary-grid"> 
        ${meterList('Top Screens', data.screen || [])}
        ${meterList('Top Sections', data.section || [])}
      </div>
      <div class="decomp-summary-grid"> 
        ${meterList('Top Fields', data.field || [])}
        ${meterList('Top Errors', data.code || [])}
      </div>
      <div class="decomp-grid">
        ${meterList('Action', data.action || [])}
        ${meterList('Assertion', data.assertion || [])}
      </div>
      <div class="decomp-card" style="margin-top:10px;">
        <div style="font-weight:600">Evidence 샘플 <span class="mini">(${(data.evidence || []).length})</span></div>
        <ul class="decomp-evidence-list">${(data.evidence || []).map((x) => `<li><span class="code-chip mono">${safeText(x.code)}</span> ${safeText(x.scenario)} · ${safeText(x.evidence).slice(0, 200)}</li>`).join('') || '<li>(없음)</li>'}</ul>
      </div>
      ${(Array.isArray(data.rows) && data.rows.length) ? `
      <div class="decomp-toolbar">
        <input id="decompFilterInput" type="text" placeholder="화면/섹션/필드/액션/검증/에러/증거 검색" />
        <select id="decompScreenSelect"><option value="">모든 화면</option>${Array.from(new Set(data.rows.map((row) => safeText(row.screen || '').trim()).filter(Boolean))).sort().map((name) => `<option value="${encodeURIComponent(name)}">${safeText(name)}</option>`).join('')}</select>
        <select id="decompSectionSelect"><option value="">모든 섹션</option>${Array.from(new Set(data.rows.map((row) => safeText(row.section || '').trim()).filter(Boolean))).sort().map((name) => `<option value="${encodeURIComponent(name)}">${safeText(name)}</option>`).join('')}</select>
        <select id="decompErrorSelect"><option value="">모든 error code</option>${Array.from(new Set(data.rows.map((row) => safeText(row.error || '').trim()).filter(Boolean))).sort().map((code) => `<option value="${encodeURIComponent(code)}">${safeText(code)}</option>`).join('')}</select>
        <select id="decompEvidenceSelect"><option value="ALL">증거 전체</option><option value="MISSING">증거 누락만</option><option value="HAS">증거 있는 행만</option></select>
        <select id="decompPageSize"><option value="20">20행</option><option value="40" selected>40행</option><option value="80">80행</option></select>
        <button id="decompPrevBtn" class="btn secondary" type="button">이전</button>
        <button id="decompNextBtn" class="btn secondary" type="button">다음</button>
        <span class="decomp-muted-chip" id="decompPageInfo"></span>
        <span class="decomp-muted-chip" id="decompRowCount"></span>
      </div>
      <div class="decomp-row-wrap">
        <table class="decomp-row-table">
          <thead><tr><th>#</th><th>Screen</th><th>Section</th><th>Field</th><th>Action</th><th>Assertion</th><th>Error</th><th>Evidence</th></tr></thead>
          <tbody id="decompRowBody"></tbody>
        </table>
      </div>
      <div class="mini" style="margin-top:6px">executed decomposition rows source: ${safeText(data.source || 'unknown')} (${data.rows.length}건, page 렌더링 적용)</div>
      ` : ''}
    `;

    if (!(Array.isArray(data.rows) && data.rows.length)) return;

    const filterInput = document.getElementById('decompFilterInput');
    const screenSelect = document.getElementById('decompScreenSelect');
    const sectionSelect = document.getElementById('decompSectionSelect');
    const errorSelect = document.getElementById('decompErrorSelect');
    const evidenceSelect = document.getElementById('decompEvidenceSelect');
    const pageSizeSelect = document.getElementById('decompPageSize');
    const prevBtn = document.getElementById('decompPrevBtn');
    const nextBtn = document.getElementById('decompNextBtn');
    const body = document.getElementById('decompRowBody');
    const rowCount = document.getElementById('decompRowCount');
    const pageInfo = document.getElementById('decompPageInfo');
    if (!filterInput || !screenSelect || !sectionSelect || !errorSelect || !evidenceSelect || !pageSizeSelect || !prevBtn || !nextBtn || !body || !rowCount || !pageInfo) return;

    const rows = data.rows.slice(0, 1500);
    let filtered = rows;
    let page = 1;

    const applyFilter = () => {
      const q = String(filterInput.value || '').trim().toLowerCase();
      const screenFilter = decodeURIComponent(String(screenSelect.value || ''));
      const sectionFilter = decodeURIComponent(String(sectionSelect.value || ''));
      const codeFilter = decodeURIComponent(String(errorSelect.value || ''));
      const evidenceFilter = String(evidenceSelect.value || 'ALL');
      filtered = rows.filter((row) => {
        if (screenFilter && safeText(row.screen) !== screenFilter) return false;
        if (sectionFilter && safeText(row.section) !== sectionFilter) return false;
        if (codeFilter && safeText(row.error) !== codeFilter) return false;
        if (evidenceFilter === 'MISSING' && row.hasEvidence) return false;
        if (evidenceFilter === 'HAS' && !row.hasEvidence) return false;
        if (!q) return true;
        const blob = `${safeText(row.screen)} ${safeText(row.section)} ${safeText(row.field)} ${safeText(row.action)} ${safeText(row.assertion)} ${safeText(row.error)} ${safeText(row.evidence)}`.toLowerCase();
        return blob.includes(q);
      });
      page = 1;
      renderPage();
    };

    const renderPage = () => {
      const pageSize = Math.max(20, Number(pageSizeSelect.value || 40));
      const total = filtered.length;
      const totalPages = Math.max(1, Math.ceil(total / pageSize));
      if (page > totalPages) page = totalPages;
      const start = (page - 1) * pageSize;
      const view = filtered.slice(start, start + pageSize);

      rowCount.textContent = `표시 ${view.length} / ${total}건`;
      pageInfo.textContent = `page ${page}/${totalPages}`;
      prevBtn.disabled = page <= 1;
      nextBtn.disabled = page >= totalPages;

      requestAnimationFrame(() => {
        if (!view.length) {
          body.innerHTML = '<tr><td colspan="8" class="mini">조건에 맞는 행이 없습니다.</td></tr>';
          return;
        }
        body.innerHTML = view.map((row, idx) => {
          const evidenceClass = row.hasEvidence ? '' : 'decomp-evidence-missing';
          return `<tr><td>${start + idx + 1}</td><td>${safeText(row.screen)}</td><td>${safeText(row.section)}</td><td>${safeText(row.field)}</td><td>${safeText(row.action)}</td><td>${safeText(row.assertion)}</td><td><span class="code-chip mono">${safeText(row.error)}</span></td><td class="mono ${evidenceClass}">${safeText(row.evidence).slice(0, 240)}</td></tr>`;
        }).join('');
      });
    };

    let filterTimer = null;
    filterInput.addEventListener('input', () => {
      if (filterTimer) clearTimeout(filterTimer);
      filterTimer = setTimeout(applyFilter, 120);
    });
    screenSelect.addEventListener('change', applyFilter);
    sectionSelect.addEventListener('change', applyFilter);
    errorSelect.addEventListener('change', applyFilter);
    evidenceSelect.addEventListener('change', applyFilter);
    pageSizeSelect.addEventListener('change', () => { page = 1; renderPage(); });
    prevBtn.addEventListener('click', () => { if (page > 1) { page -= 1; renderPage(); } });
    nextBtn.addEventListener('click', () => {
      const pageSize = Math.max(20, Number(pageSizeSelect.value || 40));
      const totalPages = Math.max(1, Math.ceil(filtered.length / pageSize));
      if (page < totalPages) { page += 1; renderPage(); }
    });

    applyFilter();
  }



  function safeText(v) {
    if (v == null) return '';
    if (typeof v === 'string') return v;
    try { return JSON.stringify(v); } catch (_) { return String(v); }
  }

  function pickMeta(meta, key) {
    if (!meta || typeof meta !== 'object') return '';
    return meta[key] == null ? '' : String(meta[key]);
  }

  const FAILURE_REMEDIATION_HINTS = {
    ELEMENT_NOT_FOUND: '선택자(data-testid)와 UI 텍스트가 최신 화면과 맞는지 확인하고 체크리스트 시나리오를 갱신하세요.',
    ELEMENT_NOT_VISIBLE: '가시성 조건(탭/아코디언/모달 오픈)이 선행되어야 하는지 점검하고 필요한 선행 step을 추가하세요.',
    CLICK_FAILED: '클릭 대상이 overlay/disabled 상태인지 확인하고, 안정화 대기 또는 대체 selector를 지정하세요.',
    TYPE_FAILED: '입력 필드가 readonly/format-mask인지 확인하고 유효한 샘플 입력값으로 교체하세요.',
    ASSERTION_FAILED: '기대 결과 문구/URL/상태값 정의를 실제 정책과 맞추고 허용 오차(시간/문구)를 조정하세요.',
    TIMEOUT: '응답 지연 구간입니다. 백엔드 응답 시간과 로딩 인디케이터 종료 시점을 점검하고 timeout/재시도를 조정하세요.',
    NETWORK: '실패한 API/정적 리소스 경로를 확인하고 CORS, 인증 토큰, 배포 경로 설정을 점검하세요.',
    HTTP_4XX: '권한/요청 파라미터 문제 가능성이 큽니다. 인증 상태와 요청 payload를 재검증하세요.',
    HTTP_5XX: '서버 오류입니다. 실패 API 로그를 확인해 백엔드 예외를 우선 조치하세요.',
    AUTH_REQUIRED: '테스트 계정 또는 로그인 세션이 필요합니다. 관리자/사용자 계정 설정 후 재실행하세요.',
    BLOCKED: '선행 조건 부족(권한/데이터/환경)입니다. precondition을 체크리스트에 명시하세요.',
  };

  function remediationHintFor(code) {
    const key = String(code || '').trim().toUpperCase();
    if (!key || key === 'OK') return '';
    if (FAILURE_REMEDIATION_HINTS[key]) return FAILURE_REMEDIATION_HINTS[key];
    if (key.includes('TIMEOUT')) return FAILURE_REMEDIATION_HINTS.TIMEOUT;
    if (key.includes('NOT_FOUND')) return FAILURE_REMEDIATION_HINTS.ELEMENT_NOT_FOUND;
    if (key.includes('NOT_VISIBLE')) return FAILURE_REMEDIATION_HINTS.ELEMENT_NOT_VISIBLE;
    if (key.includes('AUTH')) return FAILURE_REMEDIATION_HINTS.AUTH_REQUIRED;
    if (key.includes('NETWORK') || key.includes('REQUEST') || key.includes('RESOURCE')) return FAILURE_REMEDIATION_HINTS.NETWORK;
    if (key.includes('4XX') || key.includes('HTTP_4')) return FAILURE_REMEDIATION_HINTS.HTTP_4XX;
    if (key.includes('5XX') || key.includes('HTTP_5')) return FAILURE_REMEDIATION_HINTS.HTTP_5XX;
    if (key.includes('BLOCK')) return FAILURE_REMEDIATION_HINTS.BLOCKED;
    return '실패 코드 기준 가이드가 없습니다. raw 로그/증거를 확인해 재현 후 체크리스트를 보강하세요.';
  }

  function remediationGroupFor(code) {
    const key = String(code || '').toUpperCase();
    if (key.includes('HTTP_5') || key.includes('5XX') || key.includes('NETWORK')) return '백엔드/네트워크';
    if (key.includes('AUTH') || key.includes('BLOCK') || key.includes('4XX')) return '권한/정책';
    if (key.includes('TIMEOUT')) return '성능/타이밍';
    if (key.includes('ASSERT') || key.includes('NOT_FOUND') || key.includes('NOT_VISIBLE') || key.includes('CLICK') || key.includes('TYPE')) return '시나리오/선택자';
    return '기타';
  }

  function buildRemediationChecklist(codes, counts) {
    const lines = ['[Remediation Action Checklist]'];
    const groupCounts = {};
    codes.forEach(code => {
      const g = remediationGroupFor(code);
      groupCounts[g] = (groupCounts[g] || 0) + (counts[code] || 0);
    });
    const orderedGroups = Object.keys(groupCounts).sort((a,b)=>groupCounts[b]-groupCounts[a]);
    orderedGroups.forEach(g => lines.push(`- [ ] ${g} 점검 (${groupCounts[g]}건)`));
    lines.push('');
    codes.forEach(code => lines.push(`- [ ] ${code} (${counts[code]}건): ${remediationHintFor(code)}`));
    return lines.join('\n');
  }

  function copyText(text) {
    const payload = String(text || '');
    if (!payload) return;
    if (navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(payload).then(() => alert('조치 체크리스트를 복사했습니다.')).catch(() => {
        alert('복사 실패: 수동으로 텍스트를 복사해주세요.');
      });
      return;
    }
    alert('복사 실패: 브라우저에서 클립보드를 지원하지 않습니다.');
  }

  function renderRemediationHints(rows) {
    const box = document.getElementById('remediationHints');
    const list = Array.isArray(rows) ? rows : [];
    const counts = {};
    const groupCounts = {};

    list.forEach(r => {
      const code = String(r['실패코드'] || '').trim();
      if (!code || code === 'OK') return;
      counts[code] = (counts[code] || 0) + 1;
      const group = remediationGroupFor(code);
      groupCounts[group] = (groupCounts[group] || 0) + 1;
    });

    const codes = Object.keys(counts).sort((a,b)=>(counts[b]-counts[a]));
    if (!codes.length) {
      box.style.display = 'none';
      box.innerHTML = '';
      return;
    }

    const checklist = buildRemediationChecklist(codes, counts);
    const groupSummary = Object.keys(groupCounts).sort((a,b)=>(groupCounts[b]-groupCounts[a]))
      .map(group => `<span class="summary-chip">${group} ${groupCounts[group]}건</span>`).join('');

    box.style.display = 'block';
    box.innerHTML = `<div style="font-weight:700">실패코드별 조치 가이드</div><div class="mini" style="margin-top:4px">execute 결과를 기준으로 우선순위 높은 코드부터 제안합니다.</div><div class="remediation-summary">${groupSummary}</div>` +
      codes.map(code => {
        const hint = remediationHintFor(code);
        const group = remediationGroupFor(code);
        return `<div class="remediation-item"><div><span class="code-chip mono">${code}</span> <span class="mini">${counts[code]}건 · ${group}</span></div><div style="margin-top:4px">${hint}</div></div>`;
      }).join('') +
      `<div class="checklist-box"><div class="row"><div style="font-weight:600">복붙용 액션 체크리스트</div><button id="copyRemediationChecklistBtn" class="btn secondary checklist-copy">복사</button></div><pre id="remediationChecklistText" class="mini mono" style="margin-top:6px; max-height:180px; white-space:pre-wrap;">${safeText(checklist)}</pre></div>`;

    const copyBtn = document.getElementById('copyRemediationChecklistBtn');
    if (copyBtn) copyBtn.onclick = () => copyText(checklist);
  }

  function renderExecutedRowsTable(rows) {
    const list = Array.isArray(rows) ? rows : [];
    const body = document.getElementById('execRowsBody');
    const wrap = document.getElementById('execRowsWrap');
    const hint = document.getElementById('execEvidenceHint');
    body.innerHTML = '';

    if (!list.length) {
      wrap.style.display = 'none';
      hint.textContent = '실행 증거 상세: 대기';
      return;
    }

    wrap.style.display = 'block';
    hint.textContent = `실행 증거 상세: ${list.length}건`;

    list.forEach((r, idx) => {
      const meta = (r['실행메타'] && typeof r['실행메타'] === 'object') ? r['실행메타'] : {};
      const stat = (r['요소통계'] && typeof r['요소통계'] === 'object') ? r['요소통계'] : {};
      const result = String(r['실행결과'] || '-');
      const code = String(r['실패코드'] || '-');
      const evidence = safeText(r['증거'] || '').slice(0, 180);
      const metaLine = [
        pickMeta(meta, 'scenarioKind'),
        pickMeta(meta, 'urlAfter') || pickMeta(meta, 'urlBefore'),
        pickMeta(meta, 'durationMs') ? `${pickMeta(meta, 'durationMs')}ms` : ''
      ].filter(Boolean).join(' · ');
      const statLine = Object.keys(stat).length ? Object.entries(stat).map(([k,v]) => `${k}:${v}`).join(' | ') : '';

      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td class="mini">${idx + 1}</td>
        <td><span class="badge ${result === 'PASS' ? 'PASS' : (result === 'FAIL' ? 'FAIL' : '')}">${result}</span></td>
        <td><div>${safeText(r['화면'] || '-')}</div><div class="mini">${safeText(r['구분'] || '-')}</div></td>
        <td>${safeText(r['테스트시나리오'] || '-')}</td>
        <td><span class="code-chip mono">${code}</span></td>
        <td>${safeText(r['실패사유'] || '-')}</td>
        <td class="mini mono">${evidence || '-'}</td>
        <td><div class="mini">${metaLine || '-'}</div><div class="mini mono">${statLine || ''}</div></td>
      `;
      body.appendChild(tr);
    });
  }

  function normalizeRetryClass(raw) {
    const v = String(raw || '').trim();
    return v || 'UNCLASSIFIED';
  }

  function rowRetryClass(row) {
    const meta = (row && typeof row['실행메타'] === 'object') ? row['실행메타'] : {};
    return normalizeRetryClass(
      row?.retryClass || row?.['재시도분류'] || row?.['retryClass'] ||
      meta.retryClass || meta.retry_class || meta.retryCategory ||
      meta['재시도분류'] || meta['retry_class']
    );
  }

  function renderRetryStatsPanel(rows, retryStats) {
    const box = document.getElementById('retryStatsPanel');
    if (!box) return;

    const statsObj = (retryStats && typeof retryStats === 'object') ? retryStats : {};
    const topStats = Object.entries(statsObj).filter(([k]) => !['byClass', 'classes', 'classSummary'].includes(k));
    const classStatsRaw = statsObj.byClass || statsObj.classes || statsObj.classSummary || {};

    const classCounts = {};
    if (classStatsRaw && typeof classStatsRaw === 'object') {
      Object.entries(classStatsRaw).forEach(([k, v]) => {
        const n = Number(v);
        classCounts[k] = Number.isFinite(n) ? n : (Number(v?.count) || 0);
      });
    }

    const list = Array.isArray(rows) ? rows : [];
    list.forEach((r) => {
      const cls = rowRetryClass(r);
      classCounts[cls] = (classCounts[cls] || 0) + 1;
    });

    const classEntries = Object.entries(classCounts).filter(([,v]) => Number(v) > 0).sort((a,b)=>Number(b[1])-Number(a[1]));
    const hasData = topStats.length || classEntries.length;
    if (!hasData) {
      box.style.display = 'none';
      box.innerHTML = '';
      return;
    }

    const topRows = topStats.map(([k,v]) => `<li><span class="code-chip mono">${safeText(k)}</span> ${safeText(v)}</li>`).join('');
    const classRows = classEntries.map(([k,v]) => `<li><span class="code-chip mono">${safeText(k)}</span> ${safeText(v)}건</li>`).join('');

    box.style.display = 'block';
    box.innerHTML = `
      <div style="font-weight:700">재시도 통계 요약</div>
      <div class="retry-grid">
        <div>
          <div class="mini" style="margin-top:6px">execute.retryStats</div>
          <ul class="retry-list">${topRows || '<li>데이터 없음</li>'}</ul>
        </div>
        <div>
          <div class="mini" style="margin-top:6px">행 단위 재시도 분류 요약</div>
          <ul class="retry-list">${classRows || '<li>분류 없음</li>'}</ul>
        </div>
      </div>
    `;
  }

  function extractParitySignals(payload) {
    const signals = [];
    const seen = new Set();

    function pushSignal(value) {
      if (value == null) return;
      const text = String(value).trim();
      if (!text) return;
      if (seen.has(text)) return;
      seen.add(text);
      signals.push(text);
    }

    function pushFromArray(arr) {
      if (!Array.isArray(arr)) return;
      arr.forEach((item) => {
        if (typeof item === 'string' || typeof item === 'number' || typeof item === 'boolean') pushSignal(item);
        else if (item && typeof item === 'object') {
          pushSignal(item.message || item.reason || item.code || item.type || item.path);
        }
      });
    }

    const root = (payload && typeof payload === 'object') ? payload : {};
    const candidates = [
      root.parity,
      root.parityDrift,
      root.parityMismatch,
      root.mismatchIndicators,
      root.mismatch,
      root.drift,
      root.warnings,
      root.summary,
      root.meta,
      root.coverage,
      root.executionInsights,
      root.insights,
    ].filter(Boolean);

    candidates.forEach((obj) => {
      if (!obj || typeof obj !== 'object') return;
      pushFromArray(obj.mismatchIndicators);
      pushFromArray(obj.indicators);
      pushFromArray(obj.mismatches);
      pushFromArray(obj.drifts);
      pushFromArray(obj.warnings);
      if (obj.isDrift === true || obj.hasMismatch === true || obj.mismatch === true || obj.detected === true) {
        pushSignal(obj.message || obj.reason || 'Parity drift/mismatch detected by backend');
      }
      pushSignal(obj.parityDriftMessage);
      pushSignal(obj.mismatchMessage);
    });

    return signals.slice(0, 8);
  }

  function renderParityDriftPanel(payload) {
    const box = document.getElementById('parityDriftPanel');
    if (!box) return;
    const signals = extractParitySignals(payload);
    if (!signals.length) {
      box.style.display = 'none';
      box.innerHTML = '';
      return;
    }

    box.style.display = 'block';
    box.innerHTML = `<div style="font-weight:700">⚠️ Parity Drift 경고</div><div class="mini" style="margin-top:4px">백엔드 응답에서 실행 결과 불일치(mismatch) 신호가 감지되었습니다. 상세 원인 확인 후 재실행하세요.</div><ul class="parity-drift-list">${signals.map(s => `<li>${safeText(s)}</li>`).join('')}</ul>`;
  }

  function renderFailureCodeStats(rows, payload = null) {
    const list = Array.isArray(rows) ? rows : [];
    const counts = {};
    list.forEach(r => {
      const code = String(r['실패코드'] || '').trim();
      if (!code || code === 'OK') return;
      counts[code] = (counts[code] || 0) + 1;
    });

    const statEl = document.getElementById('failCodeStats');
    const sel = document.getElementById('failCodeFilter');
    sel.innerHTML = '<option value="ALL">ALL</option>';
    Object.keys(counts).sort((a,b)=>(counts[b]-counts[a])).forEach(code => {
      const op = document.createElement('option');
      op.value = code;
      op.textContent = `${code} (${counts[code]})`;
      sel.appendChild(op);
    });

    const chips = Object.keys(counts).sort((a,b)=>(counts[b]-counts[a])).map(code => `${code}:${counts[code]}`);
    statEl.textContent = chips.length ? `실패코드 집계: ${chips.join(' | ')}` : '실패코드 집계: 없음';
    renderRemediationHints(list);
    lastFineErrorDecomp = collectErrorDecomposition(list, payload);
    renderFineErrorDecompPanel(lastFineErrorDecomp);
  }

  function applyFailureCodeFilter() {
    const code = (document.getElementById('failCodeFilter')?.value || 'ALL');
    if (!Array.isArray(lastExecutedRows) || !lastExecutedRows.length) {
      renderExecutedRowsTable([]);
      return;
    }
    const rows = (code === 'ALL') ? lastExecutedRows : lastExecutedRows.filter(r => String(r['실패코드'] || '') === code);
    document.getElementById('rawOut').textContent = JSON.stringify({ filteredBy: code, count: rows.length, rows }, null, 2);
    renderExecutedRowsTable(rows);
  }

  function firstObj(...items) {
    for (const item of items) {
      if (item && typeof item === 'object') return item;
    }
    return null;
  }

  function toNum(v) {
    const n = Number(v);
    return Number.isFinite(n) ? n : null;
  }

  function normalizeLaneStatus(value) {
    if (value == null) return null;
    if (typeof value === 'boolean') return value ? 'PASS' : 'FAIL';
    const raw = String(value).trim();
    if (!raw) return null;
    const upper = raw.toUpperCase();
    if (['PASS', 'OK', 'SUCCESS', 'HEALTHY', 'UP'].includes(upper)) return 'PASS';
    if (['FAIL', 'FAILED', 'ERROR', 'DOWN', 'UNHEALTHY'].includes(upper)) return 'FAIL';
    if (['WARN', 'WARNING', 'DEGRADED'].includes(upper)) return 'WARN';
    return upper;
  }

  function readLaneStatusFromObject(obj) {
    if (!obj || typeof obj !== 'object') return null;
    const readStatus = (v) => normalizeLaneStatus(v?.status ?? v?.result ?? v?.laneStatus ?? v?.finalStatus ?? v?.state ?? v?.ok ?? v);

    const nodeCandidate = obj?.node ?? obj?.nodejs ?? obj?.nodeLane ?? obj?.nodeStatus ?? obj?.nodeResult;
    const fastapiCandidate = obj?.fastapi ?? obj?.fastApi ?? obj?.fastapiLane ?? obj?.fastapiStatus ?? obj?.fastapiResult ?? obj?.python;

    const nodeStatus = readStatus(nodeCandidate);
    const fastapiStatus = readStatus(fastapiCandidate);
    if (nodeStatus || fastapiStatus) return { nodeStatus, fastapiStatus };

    const laneRows = Array.isArray(obj?.lanes) ? obj.lanes : (Array.isArray(obj) ? obj : null);
    if (!laneRows) return null;

    let fromRowsNode = null;
    let fromRowsFastapi = null;
    laneRows.forEach((lane) => {
      const name = String(lane?.name || lane?.lane || lane?.service || lane?.target || '').toLowerCase();
      const status = readStatus(lane);
      if (!status) return;
      if (!fromRowsNode && (name.includes('node') || name.includes('web'))) fromRowsNode = status;
      if (!fromRowsFastapi && (name.includes('fastapi') || name.includes('python'))) fromRowsFastapi = status;
    });
    if (fromRowsNode || fromRowsFastapi) return { nodeStatus: fromRowsNode, fastapiStatus: fromRowsFastapi };
    return null;
  }

  function normalizeValidationLaneStatus(payload) {
    const root = firstObj(payload, {});
    const summaryCandidates = [
      root?.latestValidationSummary,
      root?.validationSummary,
      root?.validation?.summary,
      root?.validation?.latestSummary,
      root?.summary?.validation,
      root?.ops?.validationSummary,
      root?.validation,
      root,
    ].filter(Boolean);

    for (const summary of summaryCandidates) {
      const laneCandidates = [
        summary?.nodeVsFastapi,
        summary?.nodeFastapi,
        summary?.laneStatus,
        summary?.laneStatuses,
        summary?.backendLaneStatus,
        summary?.backends,
        summary?.services,
        summary,
      ];
      for (const candidate of laneCandidates) {
        const parsed = readLaneStatusFromObject(candidate);
        if (parsed && (parsed.nodeStatus || parsed.fastapiStatus)) return parsed;
      }
    }
    return null;
  }

  function normalizeValidationDelta(payload) {
    const root = firstObj(payload, {});
    const candidateRoots = [
      root?.latestValidationDelta,
      root?.validationDelta,
      root?.validation?.delta,
      root?.validation?.latestDelta,
      root?.delta,
      root?.latestDelta,
    ].filter(Boolean);

    const source = firstObj(...candidateRoots) || root;
    const flipsRaw = source?.passFailFlips || source?.statusFlips || source?.flips || source?.passFailChanges || [];
    const driftsRaw = source?.candidateDrifts || source?.candidateDrift || source?.driftBadges || source?.candidateChanges || [];

    const flips = (Array.isArray(flipsRaw) ? flipsRaw : []).map((x) => {
      const from = String(x?.from || x?.prevStatus || x?.previous || '-').toUpperCase();
      const to = String(x?.to || x?.nextStatus || x?.current || '-').toUpperCase();
      const name = String(x?.scenario || x?.name || x?.screen || x?.id || '-');
      return { name, from, to };
    }).filter((x) => x.name && x.name !== '-');

    const drifts = (Array.isArray(driftsRaw) ? driftsRaw : []).map((x) => {
      const name = String(x?.name || x?.candidate || x?.scenario || x?.id || '-');
      const prev = toNum(x?.prevScore ?? x?.before ?? x?.previous);
      const curr = toNum(x?.score ?? x?.after ?? x?.current);
      const delta = toNum(x?.delta ?? ((prev != null && curr != null) ? (curr - prev) : null));
      const reason = String(x?.reason || x?.message || '').trim();
      return { name, prev, curr, delta, reason };
    }).filter((x) => x.name && x.name !== '-');

    if (!flips.length && !drifts.length) return null;
    return { flips, drifts };
  }

  function boolOrStatus(value) {
    if (value == null) return null;
    if (typeof value === 'boolean') return value ? 'PASS' : 'FAIL';
    const norm = normalizeLaneStatus(value);
    if (norm) return norm;
    const txt = String(value).trim();
    return txt ? txt.toUpperCase() : null;
  }

  function normalizeAntiRegressionGate(payload) {
    const root = firstObj(payload, {});
    const source = firstObj(
      root?.antiRegressionGate,
      root?.antiRegression,
      root?.qualityGate,
      root?.regressionGate,
      root?.gates?.antiRegression,
      root?.gates,
      root?.quality?.antiRegressionGate,
      root?.quality,
      root
    );
    if (!source) return null;

    const parityRaw = source?.parityGate ?? source?.parity ?? source?.parityReadiness ?? source?.parity_ready ?? source?.parityStatus;
    const fineRaw = source?.fineChecklistGate ?? source?.fineChecklist ?? source?.fineChecklistReadiness ?? source?.fine_checklist_readiness ?? source?.fineChecklistStatus;
    const overallRaw = source?.overall ?? source?.status ?? source?.gateStatus ?? source?.result;

    const parity = boolOrStatus(parityRaw);
    const fineChecklist = boolOrStatus(fineRaw);
    const overall = boolOrStatus(overallRaw);

    const reasonsRaw = source?.reasons || source?.messages || source?.notes || source?.warnings || [];
    const reasons = (Array.isArray(reasonsRaw) ? reasonsRaw : [reasonsRaw])
      .map((x) => safeText(x).trim())
      .filter(Boolean)
      .slice(0, 6);

    if (!parity && !fineChecklist && !overall && !reasons.length) return null;
    return { parity, fineChecklist, overall, reasons };
  }

  function renderAntiRegressionGatePanel(data) {
    const box = document.getElementById('antiRegressionGatePanel');
    if (!box) return;
    const uiMode = (localStorage.getItem('QA_UI_MODE') || 'simple').trim();
    if (uiMode !== 'advanced' || !data) {
      box.style.display = 'none';
      box.innerHTML = '';
      return;
    }

    const chip = (name, status) => {
      const st = normalizeLaneStatus(status) || String(status || 'UNKNOWN').toUpperCase();
      const cls = st === 'PASS' || st === 'READY' ? 'PASS' : (st === 'WARN' ? 'PASS_WITH_WARNINGS' : 'FAIL');
      return `<span class="gate-pill">${safeText(name)} <span class="badge ${cls}" style="margin-left:4px">${safeText(st)}</span></span>`;
    };

    const reasonList = (data.reasons || []).length
      ? `<ul class="delta-list">${data.reasons.map((r) => `<li>${safeText(r)}</li>`).join('')}</ul>`
      : '';

    box.style.display = 'block';
    box.innerHTML = `
      <div style="font-weight:700">Anti-regression Gate</div>
      <div class="delta-badge-row" style="margin-top:8px;">
        ${data.overall ? chip('Overall', data.overall) : ''}
        ${data.parity ? chip('Parity', data.parity) : ''}
        ${data.fineChecklist ? chip('Fine-checklist readiness', data.fineChecklist) : ''}
      </div>
      ${reasonList}
      <div class="mini" style="margin-top:6px">payload에 anti-regression gate 결과가 있을 때만 표시됩니다.</div>
    `;
  }

  async function loadAntiRegressionGateFromPaths(payload) {
    const keys = [
      payload?.antiRegressionGatePath,
      payload?.qualityGatePath,
      payload?.paths?.antiRegressionGatePath,
      payload?.paths?.qualityGatePath,
      payload?.artifacts?.antiRegressionGatePath,
      payload?.artifacts?.qualityGatePath,
      payload?.report?.antiRegressionGatePath,
    ].filter(Boolean);
    for (const k of keys) {
      try {
        const res = await fetch(fileUrl(k));
        if (!res.ok) continue;
        const j = await res.json();
        const parsed = normalizeAntiRegressionGate(j);
        if (parsed) return parsed;
      } catch (_) {}
    }
    return null;
  }

  async function hydrateAntiRegressionGate(payload) {
    const parsed = normalizeAntiRegressionGate(payload);
    if (parsed) return parsed;
    return await loadAntiRegressionGateFromPaths(payload || {});
  }

  async function loadValidationLaneStatusFromPaths(payload) {
    const keys = [
      payload?.latestValidationSummaryPath,
      payload?.validationSummaryPath,
      payload?.paths?.latestValidationSummaryPath,
      payload?.paths?.validationSummaryPath,
      payload?.artifacts?.latestValidationSummaryPath,
      payload?.artifacts?.validationSummaryPath,
      payload?.report?.latestValidationSummaryPath,
      payload?.report?.validationSummaryPath,
      payload?.latest?.validationSummaryPath,
    ].filter(Boolean);
    for (const k of keys) {
      try {
        const res = await fetch(fileUrl(k));
        if (!res.ok) continue;
        const j = await res.json();
        const normalized = normalizeValidationLaneStatus(j);
        if (normalized) return normalized;
      } catch (_) {}
    }
    return null;
  }

  async function hydrateValidationLaneStatus(payload) {
    const fromPayload = normalizeValidationLaneStatus(payload);
    if (fromPayload) return fromPayload;
    return await loadValidationLaneStatusFromPaths(payload || {});
  }

  async function loadValidationDeltaFromPaths(payload) {
    const keys = [
      payload?.latestValidationDeltaPath,
      payload?.validationDeltaPath,
      payload?.paths?.latestValidationDeltaPath,
      payload?.paths?.validationDeltaPath,
      payload?.artifacts?.latestValidationDeltaPath,
      payload?.artifacts?.validationDeltaPath,
      payload?.report?.latestValidationDeltaPath,
      payload?.report?.validationDeltaPath,
      payload?.latest?.validationDeltaPath,
    ].filter(Boolean);
    for (const k of keys) {
      try {
        const res = await fetch(fileUrl(k));
        if (!res.ok) continue;
        const j = await res.json();
        const normalized = normalizeValidationDelta(j);
        if (normalized) return normalized;
      } catch (_) {}
    }
    return null;
  }

  async function hydrateValidationDelta(payload) {
    const fromPayload = normalizeValidationDelta(payload);
    if (fromPayload) return fromPayload;
    return await loadValidationDeltaFromPaths(payload || {});
  }

  function renderValidationLanePanel(data) {
    const box = document.getElementById('validationLanePanel');
    if (!box) return;
    const uiMode = (localStorage.getItem('QA_UI_MODE') || 'simple').trim();
    if (uiMode !== 'advanced' || !data || (!data.nodeStatus && !data.fastapiStatus)) {
      box.style.display = 'none';
      box.innerHTML = '';
      return;
    }

    const chip = (name, status) => {
      const state = normalizeLaneStatus(status) || 'UNKNOWN';
      const cls = state === 'PASS' ? 'PASS' : (state === 'WARN' ? 'PASS_WITH_WARNINGS' : (state === 'FAIL' ? 'FAIL' : 'PASS_WITH_WARNINGS'));
      return `<span class="summary-chip">${safeText(name)} <span class="badge ${cls}" style="margin-left:6px">${safeText(state)}</span></span>`;
    };

    box.style.display = 'block';
    box.innerHTML = `
      <div style="font-weight:700">Node vs FastAPI Lane Status</div>
      <div class="delta-badge-row">
        ${chip('Node', data.nodeStatus)}
        ${chip('FastAPI', data.fastapiStatus)}
      </div>
      <div class="mini" style="margin-top:6px">validation summary 기반 표시 (값이 있을 때만 노출)</div>
    `;
  }

  function renderValidationDeltaPanel(data) {
    const box = document.getElementById('validationDeltaPanel');
    if (!box) return;
    const uiMode = (localStorage.getItem('QA_UI_MODE') || 'simple').trim();
    if (uiMode !== 'advanced' || !data) {
      box.style.display = 'none';
      box.innerHTML = '';
      return;
    }

    const flips = Array.isArray(data.flips) ? data.flips : [];
    const drifts = Array.isArray(data.drifts) ? data.drifts : [];
    if (!flips.length && !drifts.length) {
      box.style.display = 'none';
      box.innerHTML = '';
      return;
    }

    box.style.display = 'block';
    const flipRows = flips.slice(0, 8).map((f) => `<li><span class="mono">${safeText(f.name)}</span>: <span class="code-chip">${safeText(f.from)}</span> → <span class="code-chip">${safeText(f.to)}</span></li>`).join('');
    const driftBadges = drifts.slice(0, 12).map((d) => {
      const deltaText = d.delta == null ? '-' : (d.delta > 0 ? `+${d.delta}` : `${d.delta}`);
      const scoreText = (d.prev != null && d.curr != null) ? `${d.prev}→${d.curr}` : '-';
      return `<span class="drift-badge"><b>${safeText(d.name)}</b> <span class="mini">${scoreText} (${deltaText})</span></span>`;
    }).join('');

    box.innerHTML = `
      <div style="font-weight:700">Latest Validation Delta</div>
      <div class="delta-badge-row">
        <span class="summary-chip">Pass/Fail Flip ${flips.length}건</span>
        <span class="summary-chip">Candidate Drift ${drifts.length}건</span>
      </div>
      ${flips.length ? `<div class="mini" style="margin-top:8px">최근 상태 전환</div><ul class="delta-list">${flipRows}</ul>` : ''}
      ${drifts.length ? `<div class="mini" style="margin-top:8px">Candidate drift badge</div><div>${driftBadges}</div>` : ''}
    `;
  }

  async function refreshValidationLaneStatus(payload) {
    try {
      const data = await hydrateValidationLaneStatus(payload);
      lastValidationLaneStatus = data;
      renderValidationLanePanel(lastValidationLaneStatus);
    } catch (_) {
      renderValidationLanePanel(lastValidationLaneStatus);
    }
  }

  async function refreshAntiRegressionGate(payload) {
    try {
      const data = await hydrateAntiRegressionGate(payload);
      lastAntiRegressionGate = data;
      renderAntiRegressionGatePanel(lastAntiRegressionGate);
    } catch (_) {
      renderAntiRegressionGatePanel(lastAntiRegressionGate);
    }
  }

  async function refreshValidationDelta(payload) {
    try {
      const data = await hydrateValidationDelta(payload);
      lastValidationDelta = data;
      renderValidationDeltaPanel(lastValidationDelta);
    } catch (_) {
      renderValidationDeltaPanel(lastValidationDelta);
    }
  }

  async function onOauthLogin() {
    try {
      const j = await postJson('/api/llm/oauth/start', { provider: 'openai' }, 30000, 0);
      if (!j.ok || !j.authUrl) return alert('OAuth 시작 실패');
      window.open(j.authUrl, '_blank');
      alert('로그인 창에서 인증 완료 후, "OAuth 상태" 버튼으로 연결 확인하세요.');
    } catch (e) {
      alert('OAuth 시작 실패: ' + (e?.message || e));
    }
  }

  async function onOauthStatus() {
    try {
      const j = await getJson('/api/llm/oauth/status?provider=openai', 30000);
      alert(j.connected ? `OAuth 연결됨 (${j.mode || 'oauth'})` : 'OAuth 미연결');
    } catch (e) {
      alert('OAuth 상태 조회 실패: ' + (e?.message || e));
    }
  }

  async function onOauthLogout() {
    try {
      const j = await postJson('/api/llm/oauth/logout', { provider: 'openai' }, 30000, 0);
      if (j.ok) alert('OAuth 로그아웃 완료');
    } catch (e) {
      alert('OAuth 로그아웃 실패: ' + (e?.message || e));
    }
  }

  async function onLoadTemplates() {
    try {
      setButtonBusy('loadTemplatesBtn', true, '불러오는중...');
      const j = await (await fetch(apiUrl('/api/qa/templates'))).json();
      const sel = document.getElementById('transitionTemplate');
      sel.innerHTML = '<option value="">템플릿 선택</option>';
      lastTemplates = (j.templates || []);
      lastTemplates.forEach(t => {
        const op = document.createElement('option');
        op.value = t.key;
        op.textContent = `[${t.category}] ${t.name}`;
        sel.appendChild(op);
      });
    } catch (e) {
      alert('템플릿 로드 실패: ' + (e?.message || e));
    } finally {
      setButtonBusy('loadTemplatesBtn', false);
    }
  }

  async function onRunTransition() {
    const baseUrl = document.getElementById('baseUrlInput').value.trim();
    const templateKey = document.getElementById('transitionTemplate').value;
    if (!baseUrl) return alert('URL 입력');
    if (!templateKey) return alert('템플릿 선택');
    const out = document.getElementById('transitionSummary');
    out.textContent = '전이검증 상태: 실행 중...';
    setButtonBusy('runTransitionBtn', true, '실행중...');
    try {
      const body = { templateKey, baseUrl, ...getAuthOptions() };
      const j = await (await fetch(apiUrl('/api/flow/transition-check'), {
        method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body)
      })).json();
      document.getElementById('rawOut').textContent = JSON.stringify(j, null, 2);
      if (j.ok) {
        const s = j.summary || {};
        out.textContent = `전이검증 상태: PASS ${s.PASS||0} / FAIL ${s.FAIL||0} / BLOCKED ${s.BLOCKED||0}`;
      } else {
        out.textContent = '전이검증 상태: 실패';
      }
    } catch (e) {
      out.textContent = '전이검증 상태: 실패 (예외)';
    } finally {
      setButtonBusy('runTransitionBtn', false);
    }
  }

  async function onAnalysisReload() {
    if (!lastAnalysisId) return alert('먼저 사이트 분석을 실행하세요.');
    setButtonBusy('analysisReloadBtn', true, '조회중...');
    try {
      const j = await (await fetch(apiUrl(`/api/analysis/${lastAnalysisId}`))).json();
      document.getElementById('rawOut').textContent = JSON.stringify(j, null, 2);
    } finally {
      setButtonBusy('analysisReloadBtn', false);
    }
  }

  async function onFlowMap() {
    if (!lastAnalysisId) return alert('먼저 사이트 분석을 실행하세요.');
    setButtonBusy('flowMapBtn', true, '생성중...');
    try {
      const body = {
        analysisId: lastAnalysisId,
        screen: (document.getElementById('checkScreen').value || '').trim(),
        context: (document.getElementById('checkContext').value || '').trim(),
      };
      const j = await (await fetch(apiUrl('/api/flow-map'), {
        method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body)
      })).json();
      document.getElementById('rawOut').textContent = JSON.stringify(j, null, 2);
    } finally {
      setButtonBusy('flowMapBtn', false);
    }
  }

  async function onStructureMap() {
    if (!lastAnalysisId) return alert('먼저 사이트 분석을 실행하세요.');
    setButtonBusy('structureMapBtn', true, '생성중...');
    try {
      const body = {
        analysisId: lastAnalysisId,
        screen: (document.getElementById('checkScreen').value || '').trim(),
        context: (document.getElementById('checkContext').value || '').trim(),
      };
      const j = await (await fetch(apiUrl('/api/structure-map'), {
        method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body)
      })).json();
      document.getElementById('rawOut').textContent = JSON.stringify(j, null, 2);
    } finally {
      setButtonBusy('structureMapBtn', false);
    }
  }

  async function onFlowsRun() {
    if (!lastAnalysisId) return alert('먼저 사이트 분석을 실행하세요.');
    setButtonBusy('flowsRunBtn', true, '실행중...');
    try {
      const body = { analysisId: lastAnalysisId, ...getLLMOptions() };
      const j = await (await fetch(apiUrl('/api/flows/run'), {
        method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body)
      })).json();
      document.getElementById('rawOut').textContent = JSON.stringify(j, null, 2);
      lastFlows = Array.isArray(j.flows) ? j.flows : [];
    } finally {
      setButtonBusy('flowsRunBtn', false);
    }
  }

  async function onFlowsFinalize() {
    if (!lastAnalysisId) return alert('먼저 사이트 분석을 실행하세요.');
    if (!Array.isArray(lastFlows) || !lastFlows.length) return alert('먼저 Flows 실행을 해주세요.');
    setButtonBusy('flowsFinalizeBtn', true, '확정중...');
    try {
      const body = { analysisId: lastAnalysisId, flows: lastFlows };
      const j = await (await fetch(apiUrl('/api/flows/finalize'), {
        method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body)
      })).json();
      document.getElementById('rawOut').textContent = JSON.stringify(j, null, 2);
      lastFineErrorDecomp = collectErrorDecomposition(lastExecutedRows, j);
      renderFineErrorDecompPanel(lastFineErrorDecomp);
    } finally {
      setButtonBusy('flowsFinalizeBtn', false);
    }
  }

  async function onConditionMatrix() {
    const screen = document.getElementById('checkScreen').value.trim() || document.getElementById('baseUrlInput').value.trim();
    if (!screen) return alert('화면/URL 입력');
    setButtonBusy('conditionMatrixBtn', true, '생성중...');
    try {
      const body = { screen, context: (document.getElementById('checkContext').value || '').trim(), ...getLLMOptions() };
      const j = await (await fetch(apiUrl('/api/condition-matrix'), {
        method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body)
      })).json();
      document.getElementById('rawOut').textContent = JSON.stringify(j, null, 2);
      if (!j.ok) alert('조건매트릭스 생성 실패');
    } finally {
      setButtonBusy('conditionMatrixBtn', false);
    }
  }

  function pickFirst(obj, keys) {
    if (!obj || typeof obj !== 'object') return '';
    for (const k of keys) {
      const v = obj[k];
      if (v !== undefined && v !== null && String(v).trim() !== '') return v;
    }
    return '';
  }

  function buildSheetsPayload(includeJobId = false) {
    const integrationId = (document.getElementById('sheetsIntegrationId')?.value || '').trim();
    const syncJobId = (document.getElementById('sheetsSyncJobId')?.value || '').trim();
    const spreadsheetId = (document.getElementById('sheetsSpreadsheetId')?.value || '').trim();
    const worksheet = (document.getElementById('sheetsWorksheet')?.value || '').trim();
    const payload = {};
    if (integrationId) payload.integrationId = integrationId;
    if (spreadsheetId) payload.spreadsheetId = spreadsheetId;
    if (worksheet) payload.worksheet = worksheet;
    if (includeJobId && syncJobId) payload.syncJobId = syncJobId;
    return payload;
  }

  function renderSheetsSyncStatus(status) {
    lastSheetsSyncStatus = status || null;
    const box = document.getElementById('sheetsSyncStatusBox');
    const summary = document.getElementById('sheetsSyncSummary');
    if (!box || !summary) return;
    if (!status) {
      box.style.display = 'none';
      box.innerHTML = '';
      summary.textContent = 'Sheets sync: 대기';
      return;
    }
    const s = status.status || status.syncStatus || status.state || 'UNKNOWN';
    const mode = status.mode || status.syncMode || status.direction || 'pull-only';
    const updated = status.updatedAt || status.lastUpdatedAt || status.finishedAt || status.startedAt || '-';
    const result = status.result || status.summary || status.data || status;
    summary.textContent = `Sheets sync: ${s} (${mode})`;
    box.style.display = 'block';
    box.innerHTML = `
      <div><span class="summary-chip">status: ${safeText(String(s))}</span> <span class="summary-chip">mode: ${safeText(String(mode))}</span></div>
      <div class="mini" style="margin-top:6px">updated: ${safeText(String(updated))}</div>
      <pre style="margin-top:6px;max-height:140px">${safeText(JSON.stringify(result, null, 2))}</pre>
    `;
  }

  function renderSheetsSchemaValidation(payload) {
    lastSheetsSchemaValidation = payload || null;
    const box = document.getElementById('sheetsSchemaBox');
    if (!box) return;
    if (!payload) {
      box.style.display = 'none';
      box.innerHTML = '';
      return;
    }
    const ok = Boolean(payload.ok ?? payload.valid ?? payload.schemaValid);
    const errors = payload.errors || payload.schemaErrors || payload.validationErrors || [];
    const warnings = payload.warnings || payload.schemaWarnings || [];
    const expected = payload.expectedColumns || payload.expectedSchema || [];
    const actual = payload.actualColumns || payload.detectedColumns || payload.sheetColumns || [];
    box.style.display = 'block';
    box.innerHTML = `
      <div><span class="summary-chip">schema: ${ok ? 'PASS' : 'FAIL'}</span>
      <span class="summary-chip">errors: ${(errors || []).length}</span>
      <span class="summary-chip">warnings: ${(warnings || []).length}</span></div>
      <div class="mini" style="margin-top:6px">expected: ${safeText(Array.isArray(expected) ? expected.join(', ') : JSON.stringify(expected))}</div>
      <div class="mini" style="margin-top:4px">actual: ${safeText(Array.isArray(actual) ? actual.join(', ') : JSON.stringify(actual))}</div>
      ${(errors || []).length ? `<ul class="sheet-schema-list">${errors.map((e) => `<li>${safeText(typeof e === 'string' ? e : JSON.stringify(e))}</li>`).join('')}</ul>` : '<div class="mini" style="margin-top:6px">오류 없음</div>'}
    `;
  }

  async function onSheetsPullSync() {
    setButtonBusy('sheetsPullBtn', true, '동기화중...');
    try {
      const j = await postJson('/api/integrations/google-sheets/sync/pull', buildSheetsPayload(false), 90000, 1);
      document.getElementById('rawOut').textContent = JSON.stringify(j, null, 2);
      const status = j.sync || j.status || j.data || j;
      const syncJobId = pickFirst(status, ['syncJobId', 'jobId', 'id']);
      if (syncJobId) document.getElementById('sheetsSyncJobId').value = String(syncJobId);
      renderSheetsSyncStatus(status);
      if (!j.ok) alert('Sheets pull 동기화 실패');
    } catch (e) {
      alert('Sheets pull 동기화 실패: ' + (e?.message || e));
    } finally {
      setButtonBusy('sheetsPullBtn', false);
    }
  }

  async function onSheetsSyncStatus() {
    setButtonBusy('sheetsStatusBtn', true, '조회중...');
    try {
      const payload = buildSheetsPayload(true);
      const query = new URLSearchParams();
      Object.entries(payload).forEach(([k, v]) => { if (v) query.set(k, String(v)); });
      const path = query.toString() ? `/api/integrations/google-sheets/sync/status?${query.toString()}` : '/api/integrations/google-sheets/sync/status';
      const j = await getJson(path, 60000);
      document.getElementById('rawOut').textContent = JSON.stringify(j, null, 2);
      renderSheetsSyncStatus(j.status || j.sync || j.data || j);
      if (!j.ok) alert('Sheets sync 상태 조회 실패');
    } catch (e) {
      alert('Sheets sync 상태 조회 실패: ' + (e?.message || e));
    } finally {
      setButtonBusy('sheetsStatusBtn', false);
    }
  }

  async function onSheetsSchemaValidate() {
    setButtonBusy('sheetsSchemaBtn', true, '검증중...');
    try {
      const j = await postJson('/api/integrations/google-sheets/schema/validate', buildSheetsPayload(false), 60000, 1);
      document.getElementById('rawOut').textContent = JSON.stringify(j, null, 2);
      renderSheetsSchemaValidation(j.validation || j.schemaValidation || j.data || j);
      if (!j.ok) alert('Sheets schema 검증 실패');
    } catch (e) {
      alert('Sheets schema 검증 실패: ' + (e?.message || e));
    } finally {
      setButtonBusy('sheetsSchemaBtn', false);
    }
  }

  async function onFinalizeReport() {
    const rows = lastExecutedRows?.length ? lastExecutedRows : parseTSV(lastChecklistTSV || document.getElementById('checkOut').textContent || '');
    if (!rows.length) return alert('먼저 체크리스트 실행 또는 생성 결과가 필요합니다.');
    setButtonBusy('finalizeBtn', true, '생성중...');
    try {
      const body = { projectName: 'QA 테스트시트', items: rows };
      const j = await (await fetch(apiUrl('/api/report/finalize'), {
        method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body)
      })).json();
      document.getElementById('rawOut').textContent = JSON.stringify(j, null, 2);
      lastFineErrorDecomp = collectErrorDecomposition(lastExecutedRows, j);
      renderFineErrorDecompPanel(lastFineErrorDecomp);
      if (j.ok) {
        lastFixCsv = j.finalSheet?.csv || lastFixCsv;
        lastFixXlsx = j.finalSheet?.xlsx || lastFixXlsx;
        alert('최종시트 생성 완료');
      }
    } finally {
      setButtonBusy('finalizeBtn', false);
    }
  }

  function showOpsBackendGuard(message) {
    const box = document.getElementById('opsBackendGuard');
    if (!box) return;
    box.style.display = 'block';
    box.textContent = message || '백엔드 연결이 불안정합니다. 실행은 중단되었지만 화면 상태는 유지됩니다. API 주소/연결 테스트를 확인한 뒤 다시 실행하세요.';
  }

  function hideOpsBackendGuard() {
    const box = document.getElementById('opsBackendGuard');
    if (!box) return;
    box.style.display = 'none';
    box.textContent = '';
  }

  function isBackendUnavailableError(error) {
    const msg = String(error?.message || error || '').toLowerCase();
    return (
      msg.includes('failed to fetch') ||
      msg.includes('network') ||
      msg.includes('타임아웃') ||
      msg.includes('timeout') ||
      msg.includes('json 대신 html') ||
      msg.includes('api가 json') ||
      msg.includes('abort') ||
      msg.includes('connection')
    );
  }

  async function onExecuteChecklist() {
    const rows = parseTSV(lastChecklistTSV || document.getElementById('checkOut').textContent || '');
    if (!rows.length) return alert('먼저 체크리스트를 생성하세요.');
    setButtonBusy('execBtn', true, '실행중...');
    const summaryEl = document.getElementById('execSummary');
    summaryEl.textContent = '실행 상태: 체크리스트 실행 요청 중...';
    hideOpsBackendGuard();
    resetAdvancedRunProgress();
    updateAdvancedRunProgress({}, { completed: 0, target: rows.length });
    try {
      const exhaustive = !!document.getElementById('execExhaustive').checked;
      const exhaustiveDepth = Math.max(0, parseInt(document.getElementById('exhaustiveDepth')?.value || '1', 10) || 1);
      const exhaustiveBudgetMs = Math.max(1000, parseInt(document.getElementById('exhaustiveBudgetMs')?.value || '20000', 10) || 20000);
      const allowRiskyActions = !!document.getElementById('allowRiskyActions')?.checked;
      const body = { projectName: 'QA 실행 결과', rows, exhaustive, exhaustiveClicks: 12, exhaustiveInputs: 12, exhaustiveDepth, exhaustiveBudgetMs, allowRiskyActions, ...getAuthOptions() };

      const enq = await postJson('/api/checklist/execute/async', body, 30000, 1);
      const jobId = enq.jobId;
      if (!enq.ok || !jobId) throw new Error('async 실행 요청 실패');

      let final = null;
      for (let i = 0; i < 120; i++) {
        await new Promise(r => setTimeout(r, 1500));
        const st = await getJson(`/api/checklist/execute/status/${jobId}`, 30000);
        const pg = st.progress || {};
        const pct = (pg.percent != null) ? `${pg.percent}%` : '-';
        const done = (pg.doneRows != null) ? pg.doneRows : '-';
        const total = (pg.totalRows != null) ? pg.totalRows : '-';
        summaryEl.textContent = `실행 상태: ${st.status || 'running'} (job: ${jobId}) | 진행 ${done}/${total} (${pct})`;
        updateAdvancedRunProgress(st, { completed: pg.doneRows ?? pg.done_rows ?? null, target: pg.totalRows ?? pg.total_rows ?? rows.length });
        if (st.status === 'done' || st.status === 'error') {
          final = st;
          break;
        }
      }
      if (!final) throw new Error('실행 타임아웃(폴링)');
      document.getElementById('rawOut').textContent = JSON.stringify(final, null, 2);
      if (final.ok) {
        updateAdvancedRunProgress(final, { completed: rows.length, target: rows.length });
        lastExecutedRows = final.rows || [];
        renderFailureCodeStats(lastExecutedRows, final);
        renderRetryStatsPanel(lastExecutedRows, final.retryStats);
        renderParityDriftPanel(final);
        await refreshAntiRegressionGate(final);
        await refreshValidationLaneStatus(final);
        await refreshValidationDelta(final);
        applyFailureCodeFilter();
        const s = final.summary || {};
        const c = final.coverage || {};
        const un = c.untestedEstimate || {};
        const ex = (c.exhaustive || {}).probeSummary || {};
        summaryEl.textContent = `실행 상태: PASS ${s.PASS||0} / FAIL ${s.FAIL||0} / BLOCKED ${s.BLOCKED||0} | 미실행추정 버튼 ${un.buttons||0}, 링크 ${un.links||0}, 입력 ${un.inputs||0} | 전수추가 버튼 ${ex.buttons||0}, 입력 ${ex.inputs||0} | depth ${exhaustiveDepth}, budget ${exhaustiveBudgetMs}ms, risky ${allowRiskyActions?'on':'off'}`;
      } else {
        updateAdvancedRunProgress(final, { completed: 0, target: rows.length });
        summaryEl.textContent = `실행 상태: 실패 (${final.error || 'unknown'})`;
        renderFailureCodeStats([]);
        renderRetryStatsPanel([], null);
        renderParityDriftPanel(final);
        await refreshAntiRegressionGate(final);
        await refreshValidationLaneStatus(final);
        await refreshValidationDelta(final);
        renderExecutedRowsTable([]);
      }
    } catch (e) {
      updateAdvancedRunProgress({}, { completed: 0, target: rows.length });
      if (isBackendUnavailableError(e)) {
        showOpsBackendGuard('백엔드 연결이 불안정해 실행을 완료하지 못했습니다. (non-blocking)\nAPI 주소/연결 테스트를 확인한 뒤 다시 시도하세요.');
      }
      summaryEl.textContent = '실행 상태: 실패 (예외)';
      renderFailureCodeStats([]);
      renderRetryStatsPanel([], null);
      renderParityDriftPanel(null);
      renderExecutedRowsTable([]);
      lastFineErrorDecomp = null;
      renderFineErrorDecompPanel(lastFineErrorDecomp);
      renderAntiRegressionGatePanel(lastAntiRegressionGate);
      renderValidationLanePanel(lastValidationLaneStatus);
      renderValidationDeltaPanel(lastValidationDelta);
    } finally {
      setButtonBusy('execBtn', false);
    }
  }

  async function onChecklist() {
    const screen = document.getElementById('checkScreen').value.trim();
    if (!screen) return alert('화면명 입력');
    setButtonBusy('checkBtn', true, '생성중...');
    try {
      const context = document.getElementById('checkContext').value.trim();
      const includeAuth = !!document.getElementById('checkAuth').checked;
      const j = await (await fetch(apiUrl('/api/checklist'), {
        method:'POST', headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ screen, context, includeAuth, ...getLLMOptions(), ...getAuthOptions() })
      })).json();
      document.getElementById('checkOut').textContent = j.ok ? j.tsv : JSON.stringify(j, null, 2);
      lastChecklistTSV = j.tsv || '';
      renderFineChecklistBuckets(j);
    } finally {
      setButtonBusy('checkBtn', false);
    }
  }

  document.getElementById('analyzeBtn').addEventListener('click', onAnalyze);
  document.getElementById('oneClickBtn').addEventListener('click', onOneClick);
  document.getElementById('checkBtn').addEventListener('click', onChecklist);
  document.getElementById('autoCheckBtn').addEventListener('click', onAutoChecklist);
  document.getElementById('execBtn').addEventListener('click', onExecuteChecklist);
  document.getElementById('finalizeBtn').addEventListener('click', onFinalizeReport);
  document.getElementById('loadTemplatesBtn').addEventListener('click', onLoadTemplates);
  document.getElementById('runTransitionBtn').addEventListener('click', onRunTransition);
  document.getElementById('conditionMatrixBtn').addEventListener('click', onConditionMatrix);
  document.getElementById('failCodeFilter').addEventListener('change', applyFailureCodeFilter);
  document.getElementById('analysisReloadBtn').addEventListener('click', onAnalysisReload);
  document.getElementById('flowMapBtn').addEventListener('click', onFlowMap);
  document.getElementById('structureMapBtn').addEventListener('click', onStructureMap);
  document.getElementById('flowsRunBtn').addEventListener('click', onFlowsRun);
  document.getElementById('flowsFinalizeBtn').addEventListener('click', onFlowsFinalize);
  document.getElementById('testApiBtn').addEventListener('click', testApiConnection);
  document.getElementById('oauthLoginBtn').addEventListener('click', onOauthLogin);
  document.getElementById('oauthStatusBtn').addEventListener('click', onOauthStatus);
  document.getElementById('oauthLogoutBtn').addEventListener('click', onOauthLogout);
  document.getElementById('modeSimpleBtn').addEventListener('click', () => setUIMode('simple'));
  document.getElementById('modeAdvancedBtn').addEventListener('click', () => setUIMode('advanced'));
  document.getElementById('sheetsPullBtn').addEventListener('click', onSheetsPullSync);
  document.getElementById('sheetsStatusBtn').addEventListener('click', onSheetsSyncStatus);
  document.getElementById('sheetsSchemaBtn').addEventListener('click', onSheetsSchemaValidate);

  document.getElementById('setApiBaseBtn').addEventListener('click', () => {
    const current = getApiBase();
    const next = prompt('백엔드 API 주소를 입력하세요.\n예) https://qa-mvp-api.onrender.com\n비우면 same-origin', current);
    if (next === null) return;
    const clean = String(next || '').trim().replace(/\/$/, '');
    if (clean) localStorage.setItem('QA_API_BASE', clean);
    else localStorage.removeItem('QA_API_BASE');
    refreshApiHint();
  });

  document.getElementById('openHtml').addEventListener('click', () => {
    if (!lastReportPath) return alert('먼저 실행하세요.');
    window.open(fileUrl(lastReportPath), '_blank');
  });
  document.getElementById('openJson').addEventListener('click', () => {
    if (!lastReportJson) return alert('먼저 실행하세요.');
    window.open(fileUrl(lastReportJson), '_blank');
  });
  document.getElementById('openFixCsv').addEventListener('click', () => {
    if (!lastFixCsv) return alert('Fix CSV가 없습니다. (oneclick/run 후 생성)');
    window.open(fileUrl(lastFixCsv), '_blank');
  });
  document.getElementById('openFixXlsx').addEventListener('click', () => {
    if (!lastFixXlsx) return alert('Fix XLSX가 없습니다. (oneclick/run 후 생성)');
    window.open(fileUrl(lastFixXlsx), '_blank');
  });
  document.getElementById('copyTsv').addEventListener('click', async () => {
    if (!lastChecklistTSV) return alert('먼저 체크리스트 생성');
    await navigator.clipboard.writeText(lastChecklistTSV);
    alert('복사 완료');
  });

  // initialize model placeholder/value from selected provider
  {
    const mode = (localStorage.getItem('QA_UI_MODE') || 'simple').trim();
    setUIMode(mode);
    const modelInput = document.getElementById('llmModel');
    if (!modelInput.value.trim()) modelInput.value = DEFAULT_MODEL.ollama;
    refreshApiHint();
    renderAutopilotCard();
    refreshAutopilotArtifacts();
    setTimeout(() => { testApiConnection(true).catch(() => {}); }, 200);
    setTimeout(() => { onLoadTemplates().catch(() => {}); }, 300);
  }

  document.querySelectorAll('.tab').forEach(t => {
    t.addEventListener('click', () => {
      document.querySelectorAll('.tab').forEach(x => x.classList.remove('active'));
      document.querySelectorAll('.panel').forEach(x => x.classList.remove('active'));
      t.classList.add('active');
      document.getElementById('panel-' + t.dataset.tab).classList.add('active');
    });
  });
</script>
</body>
</html>
